# 图算法
## 图的基本概念
- 背景：
    - 一笔画问题，手机解锁需要一笔画画出
    - 科尼斯堡问题，七座桥连接河岸和两个小岛，步行者怎么不重复不遗漏的一次走完七座桥
    - 现实中的计算机网络
    - 现实中的交通出行：北京地铁网络
    - 社交网络：微博

- 图的概念：
    - 图的定义：
        - 一个图可以表示为一个二元数组 $G=<V,E>$ ,
            - $V$ 表示非空顶点集，其元素称为顶点
            - $E$ 表示边集，其元素成为边
        - $e=<u,v>$表示一条边，其中$u\in V,v\in V,e\in E$
  
  <div align="center">
  <img src="./图的定义.svg" width="600" alt="图的定义" />
  </div> 
  
    - 相邻与关联
        - 相邻：
            - 边$(u,v)$连接的顶点$u$和 $v$ 相邻
        - 关联：
            - 边$(u,v)$和其连接的顶点 $u$ (或者 $v$ )相互关联

  <div align="center">
  <img src="./相邻与关联.svg" width="600" alt="相邻与关联" />
  </div> 
  
    - 度
        - 顶点的度
            - 顶点 $v$ 的度$deg(v)$ 是$v$关联的边数
        - 图的度
            - 图 $G=<V,R>$ 的度，是图各个顶点度的之和， $deg(G)=\sum_{v\in V}deg(v)$
  <div align="center">
  <img src="./度.svg" width="600" alt="度" />
  </div> 
    
    - 握手定义
        - 无向图的度是边数的两倍， $deg(G)=2|E|$
    - 路径
        - 图中包含一个顶点序列， $v_0,v_1,...v_k$ 称为 $v_0$ 到 $v_k$ 的路径
        - 路径中包含顶点 $v_0$ ,$v_1$,....,$v_k$ 和边 $(v_0,v_1),(v_1,v_2),...(v_{k-1},v_k)$
        - 存在路径 $<v_0,v_1,...v_k>$,则 $v_0$ 可达 $v_k$
        - 如果 $v_0,v_1,...v_k$ 互不相同，则路径是简单的
    - 环路
        - 如果路径 $<v_0,v_1,...v_k>$中，$v_0=v_k$ 且至少包含一条边， 则该路径构成环路
        - 如果 $v_1,...v_k$互不相同，则该环路是简单的
    - 无环图
        - 图中不存在环路
    - 连通
        - 如果图的任意对顶点互相可达，则称该图是连通的，反之称为非连通
    - 连通分量
        - 根据是否连通将顶点进行分组，互相可达的顶点集被称为连通分量
    - 子图
        - 如果 $V^{'}\subseteq  V,E^{'}\subseteq E$,则称图 $G{'}=<V^{'},E^{'}>$ 是图 $G$ 的一个子图
    - 生成子图
        - 如果$V^{'}=  V,E^{'}\subseteq E$,则称图 $G{'}=<V^{'},E^{'}>$ 是图 $G$ 的一个生成子图
    - 树
        - 连通无环图 $T=<V_T,E_T>$, 树有 $|V_T|-1$ 条边
    - 森林
        - 一至多棵树组成的无环图
- 图的表示
    - 邻接链表
        - 图 $G=<V,E>$ ,其邻接表由 $|V|$ 条链表的数组构成
        - 每一个顶点有一条链表，包含所有的与其相邻的顶点
            - $Adj[a]=\{b,d\},Adj[b]=\{a,c,d,f\}$
        - 空间大小$O(|V|+|E|)$

```python
graph = {
    "a":["b","d"],
    "b":["a","c","d","e"],
    "c":["b","f"],
    "d":["a","b","f"],
    "f":["b","c","d"]
}
```

    - 邻接矩阵
        - 图 $G=<V,E>$ 的邻接矩阵由 $|V|\times |V|$的二维数组 A构成，满足
        $$A_{ij}=\begin{cases}
        1,\quad \text{(i,j)} \in E\\
        0,\quad \text{(i,j)}\notin E
        \end{cases}$$
        - 空间大小 $O(|V|^{2})$, $O(1)$ 判断是否有边

```python
graph = [
    [0,1,0,1,0],
    [1,0,1,1,1],
    [0,1,0,0,1],
    [1,1,0,0,1],
    [0,1,1,1,0]
]
```

## 广度优先搜索（BFS）
- 算法思想
    - 现象启发：水滴落入水中所激起的涟漪会向邻区逐渐扩散
    - 核心思想：处理某节点的时候，一次性发现所有的相邻顶点,未处理的顶点加入等待队列
    - 队列：
        - 先来先服务：队尾加入，对首离开
        - 入队： $Q.Enqueue()$
        - 出队： $Q.Dequeue()$
    - 辅助数组：
        - color表示顶点状态
            - white:白色顶点 $u$ 是尚未被发现的，发现后直接入队 
            - black:黑色顶点 $u$ 已被处理，无需再次入队
            - gray:灰色顶点 $u$ 已加入队列，，无需再次入队
        - pred:顶点 $u$ 由 $pred[u]$ 发现
        - dist:顶点 $u$ 距离源点 $s$ 的距离

  <div align="center">
  <img src="./BFS.svg" width="600" alt="BFS" />
  </div>

- 复杂度分析
    - 算法运行时间 $O(|V|+|E|)$

```python
import math
from collections import deque

def BFS(G, s):
    """
    广度优先搜索（BFS）算法
    
    参数:
        G: 图的邻接表表示（字典），键为顶点，值为邻居列表
        s: 源点（起始顶点）
    
    返回:
        color: 顶点颜色数组（white=未访问, gray=已发现, black=已处理）
        dist: 源点到各顶点的最短距离
        pred: 前驱顶点数组（记录搜索树）
    """
    
    # 获取图中所有顶点的数量
    # 注意：顶点编号可能不连续，这里取最大顶点编号作为数组大小
    max_vertex = max(G.keys())
    
    # ------------------------------------------------------------------
    # 阶段1: 初始化所有顶点的状态
    # ------------------------------------------------------------------
    # color: 访问状态，"white"=未访问, "gray"=已发现, "black"=已处理
    color = ["white"] * (max_vertex + 1)
    
    # dist: 从源点s到每个顶点的距离，初始化为无穷大
    dist = [math.inf] * (max_vertex + 1)
    
    # pred: 前驱顶点（在BFS树中的父节点），None表示无前驱
    pred = [None] * (max_vertex + 1)
    
    # ------------------------------------------------------------------
    # 阶段2: 初始化源点s
    # ------------------------------------------------------------------
    # 源点标记为已发现（灰色）
    color[s] = "gray"
    # 源点到自身的距离为0
    dist[s] = 0
    # 源点无前驱
    pred[s] = None
    
    # ------------------------------------------------------------------
    # 阶段3: 创建FIFO队列并加入源点
    # ------------------------------------------------------------------
    # 重要：BFS必须使用FIFO队列（先进先出），不能使用优先队列
    # collections.deque是Python的双端队列，popleft()为O(1)，适合BFS
    Q = deque()
    Q.append(s)  # 将源点加入队列尾部
    
    # ------------------------------------------------------------------
    # 阶段4: 主循环——处理队列中的顶点
    # ------------------------------------------------------------------
    while Q:
        # 从队列头部取出顶点u（FIFO顺序）
        u = Q.popleft()
        
        # 遍历u的所有邻居v
        for v in G[u]:
            # 如果邻居v未被访问过（白色）
            if color[v] == "white":
                # 标记为已发现（灰色）
                color[v] = "gray"
                # 距离 = 前驱距离 + 1
                dist[v] = dist[u] + 1
                # 记录前驱为u
                pred[v] = u
                # 将v加入队列尾部（后续处理）
                Q.append(v)
        
        # u的所有邻居处理完毕，标记为已处理（黑色）
        color[u] = "black"
    
    # ------------------------------------------------------------------
    # 阶段5: 返回结果
    # ------------------------------------------------------------------
    return color, dist, pred


# ------------------------------------------------------------------
# 测试用例
# ------------------------------------------------------------------
if __name__ == "__main__":
    # 图的邻接表表示
    # 键为顶点编号，值为邻居列表（无向图）
    G = {
        1: [2, 5],
        2: [1, 6],
        3: [4, 6, 7],
        4: [3, 7, 8],
        5: [1],
        6: [2, 3, 7],
        7: [3, 4, 6, 8],
        8: [4, 7]
    }
    
    # 源点
    s = 2
    
    # 执行BFS
    color, dist, pred = BFS(G, s)
    
    # ------------------------------------------------------------------
    # 打印结果
    # ------------------------------------------------------------------
    print("="*50)
    print(f"BFS从源点 {s} 开始的结果")
    print("="*50)
    
    # 获取所有顶点并排序
    vertices = sorted(G.keys())
    
    print("\n顶点访问状态 (color):")
    for v in vertices:
        print(f"  顶点 {v}: {color[v]}")
    
    print("\n到源点的最短距离 (dist):")
    for v in vertices:
        if dist[v] == math.inf:
            print(f"  顶点 {v}: 不可达")
        else:
            print(f"  顶点 {v}: {int(dist[v])}")
    
    print("\n前驱顶点 (pred) - BFS树:")
    for v in vertices:
        if pred[v] is None:
            if v == s:
                print(f"  顶点 {v}: 源点（无前驱）")
            else:
                print(f"  顶点 {v}: 不可达")
        else:
            print(f"  顶点 {v}: 前驱是 {pred[v]}")
    
    print("\nBFS遍历顺序（按发现顺序）:")
    # 根据距离和发现时间重构遍历顺序
    order = sorted([(v, dist[v]) for v in vertices if dist[v] != math.inf], 
                   key=lambda x: x[1])
    print(" → ".join(str(v[0]) for v in order))
    print("="*50)
```

## 深度优先搜索（DFS）

- 算法步骤
    - 分叉时，任选一条边进行深入
    - 无边时，后退一步找新边
    - 找到边，从新边继续深入
- 辅助数组
    - color
        - white：白色表示尚未被发现
        - black：黑色表示顶点已被处理
        - gray：正在处理，尚未完成
    - pred:顶点 $u$ 由 $pred[u]$ 发现
    - d：顶点发现时刻（变成灰色的时刻）
    - f：顶点完成时刻（变成黑色的时刻）


  <div align="center">
  <img src="./DFS.svg" width="600" alt="DFS" />
  </div>

  - 算法性质
    - 深度优先树：顶点以前驱作为祖先形成的树
    - 边的性质
        - 后向边：不是树边，但两顶点在深度优先树中是祖先后代关系
        - 对于无向图，非树边一定是后向边
    - 点的性质
        - 括号化定理： 点 $v$ 发现时刻和结束时刻构成区间 $[d[v],f[v]]$
        - 任意两点 $v,w$ 必满足以下两种情况
            - $[d[v],f[v]]$ 包含 $[d[w],f[w]]$ , $w$ 是 $v$ 后代
            - $[d[w],f[w]]$ 包含 $[d[v],f[v]]$ , $v$ 是 $w$ 后代
            - $[d[w],f[w]]$ 和 $[d[v],f[v]]$ 完全不重合， $v$ 和 $w$ 均不是对方的后代

    - 路径性质
        - 白色路径定理
            - 在深度优先树中， 顶点 $v$ 是 $w$ 的祖先 等价于在 $v$ 被发现之前，从 $v$ 到 $w$ 存在全为白色的顶点构成的路径

```python
import math

def DFS(G):
    """
    深度优先搜索（DFS）算法 - 计算发现时间和结束时间
    
    参数:
        G: 图的邻接表表示（字典），键为顶点，值为邻居列表
    
    返回:
        pred: 前驱顶点数组（DFS森林）
        d: 发现时刻数组
        f: 结束时刻数组
    """
    # 获取最大顶点编号以确保数组大小足够
    max_vertex = max(G.keys())
    
    # ------------------------------------------------------------------
    # 阶段1: 初始化所有顶点的状态数组
    # ------------------------------------------------------------------
    # color: 访问状态，"white"=未访问, "gray"=已发现, "black"=已处理
    color = ["white"] * (max_vertex + 1)
    
    # pred: 前驱顶点（DFS树中的父节点），None表示无前驱
    pred = [None] * (max_vertex + 1)
    
    # d: 发现时刻（顶点首次被访问的时间），初始化为0
    d = [0] * (max_vertex + 1)
    
    # f: 结束时刻（顶点及其子树处理完毕的时间），初始化为0
    f = [0] * (max_vertex + 1)
    
    # ------------------------------------------------------------------
    # 阶段2: 时间计数器（使用列表实现引用传递）
    # ------------------------------------------------------------------
    # Python中整数是不可变的，为了在递归中正确更新时间，
    # 使用列表time[0]来存储时间戳（列表是可变对象）
    time = [0]
    
    # ------------------------------------------------------------------
    # 阶段3: 遍历所有顶点，处理每个连通分量
    # ------------------------------------------------------------------
    # 从1到max_vertex遍历，确保所有顶点都被访问
    for v in range(1, max_vertex + 1):
        # 如果顶点v存在且未被访问
        if v in G and color[v] == "white":
            # 递归访问顶点v所在的连通分量
            DFS_visit(G, v, color, d, f, pred, time)
    
    # ------------------------------------------------------------------
    # 阶段4: 返回结果
    # ------------------------------------------------------------------
    return pred, d, f


def DFS_visit(G, v, color, d, f, pred, time):
    """
    DFS递归访问函数
    
    参数:
        G: 图的邻接表
        v: 当前访问的顶点
        color: 颜色数组
        d: 发现时间数组
        f: 结束时间数组
        pred: 前驱数组
        time: 时间计数器（列表形式，用于引用传递）
    """
    # ------------------------------------------------------------------
    # 阶段1: 发现顶点v
    # ------------------------------------------------------------------
    # 将顶点标记为灰色（已发现但未处理完毕）
    color[v] = "gray"
    
    # 时间计数器加1
    time[0] += 1
    
    # 记录顶点v的发现时间
    d[v] = time[0]
    
    # ------------------------------------------------------------------
    # 阶段2: 递归访问所有白色邻居
    # ------------------------------------------------------------------
    # 遍历顶点v的所有邻居w
    for w in G[v]:
        # 如果邻居w未被访问（白色）
        if color[w] == "white":
            # 设置w的前驱为v（构建DFS树）
            pred[w] = v
            
            # 递归访问w
            DFS_visit(G, w, color, d, f, pred, time)
    
    # ------------------------------------------------------------------
    # 阶段3: 完成顶点v的处理
    # ------------------------------------------------------------------
    # 将顶点标记为黑色（已处理完毕）
    color[v] = "black"
    
    # 时间计数器加1
    time[0] += 1
    
    # 记录顶点v的结束时间
    f[v] = time[0]


# ------------------------------------------------------------------
# 主程序测试
# ------------------------------------------------------------------
if __name__ == "__main__":
    # 图的邻接表表示（无向图）
    G = {
        1: [2, 5],
        2: [1, 6],
        3: [4, 6, 7],
        4: [3, 7, 8],
        5: [1],
        6: [2, 3, 7],
        7: [3, 4, 6, 8],
        8: [4, 7]
    }
    
    # 从顶点2开始执行DFS
    pred, d, f = DFS(G)
    
    # ------------------------------------------------------------------
    # 打印结果
    # ------------------------------------------------------------------
    print("="*60)
    print("深度优先搜索（DFS）结果 - 从顶点2开始")
    print("="*60)
    
    # 获取所有顶点并排序
    vertices = sorted(G.keys())
    
    print("\n前驱顶点 (pred) - DFS树:")
    for v in vertices:
        if pred[v] is None:
            if v == 2:  # 假设从2开始
                print(f"  顶点 {v}: 根节点")
            else:
                print(f"  顶点 {v}: 不可达")
        else:
            print(f"  顶点 {v}: 前驱是 {pred[v]}")
    
    print("\n发现时间 (d):")
    for v in vertices:
        print(f"  顶点 {v}: {d[v]}")
    
    print("\n结束时间 (f):")
    for v in vertices:
        print(f"  顶点 {v}: {f[v]}")
    
    print("\n括号表示法（区间包含关系）:")
    for v in vertices:
        if d[v] > 0:
            print(f"  {v}: [{d[v]}, {f[v]}]")
    
    print("="*60)
    print(f"最大顶点编号: {max(G.keys())}")
    print(f"数组大小验证: len(pred)={len(pred)}")
    print("="*60)
```

## 有向图的深度优先搜索
- 连通无向图的优先树和有向图的优先森林
    - 无向图
        - 树的形状：取决于搜索顺序
        - 树的数量：确定1棵优先树
        - 树边：在深度优先树中的边
        - 后向边：两顶点有祖先先后代关系的非树边
    - 有向图
        - 树的形状：取决于搜索顺序
        - 树的数量：取决于搜素顺序
        - 树边：在深度优先树中的边
        - 前向边：不在深度优先树中，从祖先指向后代的边
        - 后向边：从后代指向祖先的边
        - 横向边：顶点不具有祖先后代的关系的边
    

## 有向图中的环路存在性判断
- 问题定义
    - 输入：有向图 $G=<V,E>$,其中 $V$ 是顶点集合， $E$ 是边的集合
    - 输出：图 $G$ 是否存在环
- 问题观察
    - 树边：在深度优先树中的边
    - 前向边：不管在深度优先树中，从祖先指向后代的边
    - 后向边：从后代指向祖先的边
    - 横向边：顶点不具有祖先后代关系的边

<div align="center">
<img src="./边的分类.svg" width="600" alt="DFS" />
</div>

- 猜想：有向图存在环路 $\iff$ 搜索时出现后向边

<div align="center">
<img src="./有向图判断环.svg" width="600" alt="DFS" />
</div>

## 拓扑排序
- 问题定义
    - 输入：有向无环图 $G=<V,E>$
    - 输出：图顶点 $V$ 的拓扑排序 $S$,满足对于任意有向边 $(u,v)$,排序之后 $u$ 在 $v$ 之前
- 广度优先搜索策略
    - 有向图顶点的度分为入度和出度
        - 顶点 $u$ 的入度： 终点为 $u$ 的边数
        - 顶点 $u$ 的出度： 起点为 $u$ 的边数
    - 若顶点的入度是0：所对应事件无制约，可直接完成

<div align="center">
<img src="./Topological-Sort-BFS.svg" width="600" alt="DFS" />
</div>

```python

```

- 深度优先搜索策略
    - 从DFS视角进行观察
        - 深度越深，顺序越靠后
            - 完成时刻越早：按照完成时刻逆序

<div align="center">
<img src="./Topological-Sort-DFS.svg" width="600" alt="DFS" />
</div>

```python

```

## 强连通分量

- 问题背景与定义
    - 问题背景：社交圈的划分，如何按照人群通话记录划分为不同的社交圈
    - 强连通分量
        - 一个强连通分量是顶点的子集
        - 强连通分量中任意两点可以相互可达
        - 满足最大性：加入新顶点，不保证相互可达
    - 问题定义：
        - 输入：有向图 $G=<V,E>$
        - 输出：图的所有的强连通分量 $C_1,C_2,....,C_n$


- 算法框架与实例
    - 步骤：
        - 1.把边反向，得到反向图 $G^R$
        - 2.在 $G^R$ 上执行DFS,得到顶点完成时刻顺序 $L$
        - 3.在 $G$ 按 $L$ 逆序执行DFS,得到强连通分量

- 伪代码与复杂度

<div align="center">
<img src="./Strongly-Connected-Component.svg" width="600" alt="DFS" />
</div>



## 最小生成树
- 问题背景
    - 需要修建道路来连通城市，各道路花费不同
    - 问题：连通各城市的最小花费是多少

- 概念回顾
    - 生成子图
        - 子图：如果 $V{'} \subseteq V$ , $E^{'} \subseteq E$ ，则称图 $G^{'} =<V^{'},E^{'}>$ 是图 $G$ 的一个子图
        - 生成子图：如果 $V^{'} \subseteq V $ , $E^{'} \subseteq E$,则称图 $G^{'}=<V^{'},E^{'}>$是图 $G$ 的一个生成子图
    - 生成树
        - 图 $T^{'}=<V^{'}.E^{'}>$ 是无向图 $G$ 的一个生成子图，并且是连通的、无环路的(树)
- 问题定义
    - 输入：连通无向图 $G=<V,E,W>$,其中$w(u,v)\in W$表示边$(u,v)$的权重
    - 输出：图$G$的最小生成树 
    $T=<V_T,E_T>$

    $$
    \min\sum_{e\in E_T}w(e)\\
    s.t. V_T=V,E_T\subseteq E
    $$

- 通用框架
    - 生成树是一个无向图中的连通、无环的生成子图
        - 新建一个空边集$A$，边集$A$可以扩展为最小生成树
        - 每次向边集$A$中增加一条边
            - 需要保证边集A仍是一个无环图
            - 需要保证边集A仍是最小生成树子集
    - 如何保证边集A是最小生成树子集
        - 安全边
            - A是某棵最小生成树T边的子集，$A \subseteq T$
            - $A\cup \{(u,v)\}$仍是$T$边的一个子集，称$(u,v)$是 $A$ 的安全边
        - 割
            - 图 $G=<V,E>$ 是一个连通无向图，割 $(S,V-S)$ 将图 $G$ 的顶点集 $V$ 划分为两部分
        - 横跨
            - 给定割 $(S,V-S)$和边 $(u,v)$,$u\in S$,$v\in V-S$，称边 $(u,v)$ 横跨割 $(S,V-S)$
        - 轻边
            - 横跨割的所有边中，权重最小的称为横跨这个割的一条轻边
        - 不妨害    
            - 如果一个边集A中没有边横跨某割，则成为该割不妨害边集$A$

- Prim算法
    - 算法思想
        - 1.选择任意一个顶点，作为生成树的起始顶点
        - 2.保持边集 $A$始终为一棵树，选择割 $(V_A,V-V_A)$
        - 3.选择横跨割 $(V_A,V-V_A)$ 的轻边
        - 4.重复步骤2和步骤3，直至覆盖所有的顶点
    - 辅助数组
        - color 
            - 黑色顶点$u$已覆盖， $u\in V_A$
            - 白色顶点$u$未覆盖， $u\in V-V_A$
        - dist记录横跨 $V_A,V-V_A$边的权重
            - 顶点集 $V_A$到顶点 $u$ 的最短距离，$dist[u]=\min(\{w(x,u)\}),\forall x\in V_A$
            - 轻边： $\min{\{dist[u]\}},\forall u\in V-V_A$
        - pred表示前驱顶点
            - （$pred[u],u$）为最小生成树的边

- 伪代码

<div align="center">
<img src="./Prim.svg" width="600" alt="DFS" />
</div>

- 数据结构：优先队列
    - 队列中每个元素有一个关键字，依据关键字大小离开队列
    - 通过二叉堆来实现优先队列

```python
# 优先队列
```

```python
# prim算法
```

## 最小生成树Kruskal算法
- 问题定义
    - 输入：连通无向图 $G=<V,E,W>$,其中 $w(u,v)\in W$表示边 $(u,v)$的权重
    - 输出：图 $G$的最小生成树 $T=<V_T,E_T>$
$$
\min{\sum_{e\in E_T}w(e)}\\
s.t. V_T=V,E_T\in E
$$
- 算法与实例
    - 算法思想：直接使用通用框架
        - 保证边集合 $A$ 是一个无环图（选边的时避免成环）
        - 保证边集合 $A$ 仍是最小生成树的子集（每次选择当前权重最小的边）

<div align="center">
<img src="./MST-Kruskal.svg" width="600" alt="DFS" />
</div>

```python
# Kruskal算法

```

- 不相交集合
    - 把每棵生成子树看作一个顶点的集合
        - 每个集合表示为一颗有向树，多个不相交集合构成不相交集合森林
        - 集合元素表示为树的节点
        - 树边由子结点指向父节点，根结点有一条指向自身的边
    - 初始化集合：创建根结点，并设置一条指向自身的边
    - 判定顶点是否在同一集合：回溯查找树根，检查树根是否相同
    - 合并集合：合并两棵树

```python
# Union
```

<div align="center">
<img src="./MST-Kruskal-union.svg" width="600" alt="DFS" />
</div>

```python
# Kruskal-union算法

```

| | Prim算法 | Kruskal算法 |
|---------|---------|---------|
| 核心思想   | 保持一棵树，不断扩展   | 子树森林，合并为一棵树 |
| 数据结构   | 优先队列  |  不相交集合 | 
| 求解视角   | 微观视角，基于当前点选边 | 宏观视角，基于全局顺序选边 |
| 算法策略   |都是采用贪心策略的图算法 |
## 单源最短路径问题Dijkstra算法
- 问题定义
    - 输入
        - 带权图 $G=<V,E,W>$ ，其中 $w(u,v)\geq 0$(图中所有边权为正)，$(u,v)\in E$
        - 源点编号 $s$

    - 输出
        - 源点 $s$ 到所有其他的顶点 $t$的最短距离$\delta(s,t)$和最短路径 $<s,...t>$
- 算法思想
    - 辅助数组
        - dist表示距离上界(估计距离)
            - 源点 $s$ ,$dist[s]=0$,其他顶点 $u$ ,$dist[u]$ 初始化为$\inf$
            - $dist[u]$:源点 $s$到顶点 $u$的距离上界， $\delta (s,u)\leq dist[u]$
        - color 表示顶点的状态
            - 黑色：到顶点 $u$ 的最短距离已被确定
            - 白色：到顶点 $u$ 最短路尚未被确定
        - pred表示前驱顶点
            - $(pred[u],u)$表示最短路径上的边
    - 算法思想
        - 1.新建空的黑色顶点集合 $V_A$
        - 2.选择一个空白顶点变为黑色(到该顶点最短路被确定)
        - 3.重复步骤2，直至所有的顶点均为黑色

- 算法分析
<div align="center">
<img src="./Dijkstra.svg" width="600" alt="DFS" />
</div>

```python
#dijkstra

```


<div align="center">
<img src="./Dijkstra-PriQueu.svg" width="600" alt="DFS" />
</div>

```python
#dijkstra 优先队列

```

## 单源最短路径问题Bellman-Ford算法
- 问题定义
    - 输入：1.带权图 $G = <V,E,W>$,2.源点编号 $s$
    - 输出：1.源点 $s$ 到所有其他顶点 $t$ 的最短距离 $\delta(s,t)$ 和最短路径 $<s,...t>$ 2.存在源点 $s$ 可达的负环
- 算法思想
    - 对图中存在负权边的时候，每轮对所有的边进行松弛，持续迭代 $|V|-1$轮
    - 对于图中存在源点可达负环，如果第$|V|$轮松弛成功，存在源点 $s$ 可达的负环

<div align="center">
<img src="./bellman-Ford.svg" width="600" alt="DFS" />
</div>

## 所有点对最短路径问题
- 问题定义
    - 输入：带权图 $G=<V,E,W>$, $W$是边全
    - 输出： $\forall u,v \in V$,从 $u$ 到 $v$ 的最佳路径
- 算法设计
    - 动态规划
        - 问题结构分析
            - i到j的最短路等于i到k的最短路，k到j的最短路
        - 递推关系建立
            - 不选第k个点
                - $D[k,i,j] = D[k-1,i,j]$
            - 选择第k个点
                - $D[k,i,j] = D[k-1,i,k]+D[k-1,k,j]$
        - 自底向上计算
            - 初始化
                - $D[0,i,i]=0$,起始点重合，路径长度为0
                - $D[0,i,j]=e[i,j]$,任意两点直达距离为边权
            - 递推公式
                - $D[k,i,j]=\min{D[k-1,i,j],D[k-1,i,k]+D[k-1,k,j]}$
- 伪代码

<div align="center">
<img src="./Floyd-Warshall.svg" width="600" alt="DFS" />
</div>

```python

```

## 最大流
- 流网络
    - 给定有向图 $G=<V,E,C>$， 被称为流网络    
        - 容量：对于每条边 $c(e)\geq 0$
        - 流量：对于每条边 $c(e)\geq f(e)\geq 0$
        - 剩余容量：对于每条边，剩余容量为 $c(e)- f(e)$
        - 总流量： $|f|=\sum_{e out of s}f(e=\sum_{e in to t}f(e))$
    - 流量的两条性质
        - 容量限制：对边 $e\in E$,有 $0\leq f(e)\leq c(e)$
        - 流量守恒：对顶点$v\in V-\{s,t\},\sum_{eintov}f(e)=\sum_{e out of v}f(e)$,进入某顶点 $v$ 流量和等于流入此顶点流量和

- 问题定义  
    - 输入
        - 有向图$G=<V,E,C>$，其中$c(e)\in C$表示边$e$的容量
        - 源点 $s$,汇点 $t$
    - 输出
        - 总流量$|f|$
$$
\max{|f|}=\max{\sum_{e out of s}f(e)}\\
s.t.0\leq f(e)\leq c(e),\sum_{e in to v}f(e)=\sum_{e out of v}f(e)
$$

- 残存网络
    - 给定流网络 $G=<V,E,C>$和流量 $f$,可得残存网络 $G_f=<V,E_f>$，每条边的残存容量
    -   $$
        c_f(e)=\left \{
        \begin{aligned}
        c(e)-f(e),e为正向边\\
        f(e),e为反向边
        \end{aligned}\right.
        $$
    - 给定流网络 $G=<V,E>$和流 $f$,增广路径 $p$是残存网络$G_f$中一条冲源顶点$s$到汇点$t$的简单路径（路径上的各顶点均不互相重复）
    - 增广路径上的残存容量
        - 一条增广路径 $p$ 上各边残存容量的最小值
        -   $$
            c_f(p)=\min{\{c_f(e)|e\in p\}}
            $$

- 算法思想
    - 对所有边 $e\in E$,初始化流量为0，$f(e)=0$
    - 构造残存网络 $G_f$，寻找 $s$ 到 $t$的增广路径 $P$
    - 按路径 $P$的残存容量增加流量
    - 迭代寻找路径 $P$直至无法增加路径流量

- 伪代码

<div align="center">
<img src="./Ford-Fulkerson.svg" width="600" alt="DFS" />
</div>

```python

```

## 最大二分匹配
- 相关概念
    - 二分图
        - 给定一个无向图$G=<V,E>$，其中$V=L\cup R$,$L\cap R=\phi$，并且每条边$e\in E$，有一个端点在$L$中，有一个端点在 $R$中，其可记为二分图$G=<L,R,E>$
    - 匹配
        - 图$G=<V,E>$中的一个匹配 $M$是图 $G$边集 $E$的子集 ($M\subseteq E$),其中每个顶点至多关联 $M$的一条边
- 问题定义
    - 输入
        - 二分图$G=<L,R,E>$
    - 输出
        - 求出匹配 $M=\{e_1,e_2,..,e_k\}$,令
$$
\max{|M|}\\
s.t. \forall i,j(i\neq j),e_i =(l_i,r_i),e_j=(l_j,r_j),l_i\neq l_j,r_i\neq r_j
$$

- 相关概念
    - 交替路径
        - 从未匹配的顶点出发，依次经过 "非匹配的边，匹配边，非匹配边"形成的路径
- 匈牙利算法
    - 核心思想：不断寻找交替路径进行增广
    - 辅助数组
        - matched表示 $L$与 $R$中的顶点的匹配关系，以$R$中的顶点作为下标，$matched[R_2]\leftarrow L_1$
        - color表示深度优先搜索辅助数组。white表示未搜索过，black表示已被搜索过

<div align="center">
<img src="./hungarian.svg" width="600" alt="DFS" />
</div>

