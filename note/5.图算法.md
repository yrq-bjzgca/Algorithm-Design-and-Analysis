# 图算法
## 图的基本概念
- 背景：
    - 一笔画问题，手机解锁需要一笔画画出
    - 科尼斯堡问题，七座桥连接河岸和两个小岛，步行者怎么不重复不遗漏的一次走完七座桥
    - 现实中的计算机网络
    - 现实中的交通出行：北京地铁网络
    - 社交网络：微博

- 图的概念：
    - 图的定义：
        - 一个图可以表示为一个二元数组 $G=<V,E>$  ,
            - $V$ 表示非空顶点集，其元素称为顶点
            - $E$ 表示边集，其元素成为边
        - $e=<u,v>$表示一条边，其中$u\in V,v\in V,e\in E$
  
  <div align="center">
  <img src="./图的定义.svg" width="600" alt="图的定义" />
  </div> 
  
    - 相邻与关联
        - 相邻：
            - 边$(u,v)$连接的顶点$u$和 $v$ 相邻
        - 关联：
            - 边$(u,v)$和其连接的顶点 $u$ (或者 $v$ )相互关联

  <div align="center">
  <img src="./相邻与关联.svg" width="600" alt="相邻与关联" />
  </div> 
  
    - 度
        - 顶点的度
            - 顶点 $v$ 的度$deg(v)$ 是$v$关联的边数
        - 图的度
            - 图 $G=<V,R>$ 的度，是图各个顶点度的之和， $deg(G)=\sum_{v\in V}deg(v)$
  <div align="center">
  <img src="./度.svg" width="600" alt="度" />
  </div> 
  
    - 握手定义
        - 无向图的度是边数的两倍， $deg(G)=2|E|$
    - 路径
        - 图中包含一个顶点序列， $v_0,v_1,...v_k$ 称为 $v_0$ 到 $v_k$ 的路径
        - 路径中包含顶点 $v_0$ ,$v_1$,....,$v_k$ 和边 $(v_0,v_1),(v_1,v_2),...(v_{k-1},v_k)$
        - 存在路径 $<v_0,v_1,...v_k>$,则 $v_0$ 可达 $v_k$
        - 如果 $v_0,v_1,...v_k$ 互不相同，则路径是简单的
    - 环路
        - 如果路径 $<v_0,v_1,...v_k>$中，$v_0=v_k$ 且至少包含一条边， 则该路径构成环路
        - 如果 $v_1,...v_k$互不相同，则该环路是简单的
    - 无环图
        - 图中不存在环路
    - 连通
        - 如果图的任意对顶点互相可达，则称该图是连通的，反之称为非连通
    - 连通分量
        - 根据是否连通将顶点进行分组，互相可达的顶点集被称为连通分量
    - 子图
        - 如果 $V^{'}\subseteq  V,E^{'}\subseteq E$,则称图 $G{'}=<V^{'},E^{'}>$ 是图 $G$ 的一个子图
    - 生成子图
        - 如果$V^{'}=  V,E^{'}\subseteq E$,则称图 $G{'}=<V^{'},E^{'}>$ 是图 $G$ 的一个生成子图
    - 树
        - 连通无环图 $T=<V_T,E_T>$, 树有 $|V_T|-1$ 条边
    - 森林
        - 一至多棵树组成的无环图
- 图的表示
    - 邻接链表
        - 图 $G=<V,E>$ ,其邻接表由 $|V|$ 条链表的数组构成
        - 每一个顶点有一条链表，包含所有的与其相邻的顶点
            - $Adj[a]=\{b,d\},Adj[b]=\{a,c,d,f\}$
        - 空间大小$O(|V|+|E|)$

```python
graph = {
    "a":["b","d"],
    "b":["a","c","d","e"],
    "c":["b","f"],
    "d":["a","b","f"],
    "f":["b","c","d"]
}
```

    - 邻接矩阵
        - 图 $G=<V,E>$ 的邻接矩阵由 $|V|\times |V|$的二维数组 A构成，满足
        $$A_{ij}=\begin{cases}
        1,\quad \text{(i,j)} \in E\\
        0,\quad \text{(i,j)}\notin E
        \end{cases}$$
        - 空间大小 $O(|V|^{2})$, $O(1)$ 判断是否有边

```python
graph = [
    [0,1,0,1,0],
    [1,0,1,1,1],
    [0,1,0,0,1],
    [1,1,0,0,1],
    [0,1,1,1,0]
]
```

## 广度优先搜索（BFS）
- 算法思想
    - 现象启发：水滴落入水中所激起的涟漪会向邻区逐渐扩散
    - 核心思想：处理某节点的时候，一次性发现所有的相邻顶点,未处理的顶点加入等待队列
    - 队列：
        - 先来先服务：队尾加入，对首离开
        - 入队： $Q.Enqueue()$
        - 出队： $Q.Dequeue()$
    - 辅助数组：
        - color表示顶点状态
            - white:白色顶点 $u$ 是尚未被发现的，发现后直接入队 
            - black:黑色顶点 $u$ 已被处理，无需再次入队
            - gray:灰色顶点 $u$ 已加入队列，，无需再次入队
        - pred:顶点 $u$ 由 $pred[u]$ 发现
        - dist:顶点 $u$ 距离源点 $s$ 的距离

  <div align="center">
  <img src="./BFS.svg" width="600" alt="BFS" />
  </div>

- 复杂度分析
    - 算法运行时间 $O(|V|+|E|)$

```python
import math
from collections import deque

def BFS(G, s):
    """
    广度优先搜索（BFS）算法
    
    参数:
        G: 图的邻接表表示（字典），键为顶点，值为邻居列表
        s: 源点（起始顶点）
    
    返回:
        color: 顶点颜色数组（white=未访问, gray=已发现, black=已处理）
        dist: 源点到各顶点的最短距离
        pred: 前驱顶点数组（记录搜索树）
    """
    
    # 获取图中所有顶点的数量
    # 注意：顶点编号可能不连续，这里取最大顶点编号作为数组大小
    max_vertex = max(G.keys())
    
    # ------------------------------------------------------------------
    # 阶段1: 初始化所有顶点的状态
    # ------------------------------------------------------------------
    # color: 访问状态，"white"=未访问, "gray"=已发现, "black"=已处理
    color = ["white"] * (max_vertex + 1)
    
    # dist: 从源点s到每个顶点的距离，初始化为无穷大
    dist = [math.inf] * (max_vertex + 1)
    
    # pred: 前驱顶点（在BFS树中的父节点），None表示无前驱
    pred = [None] * (max_vertex + 1)
    
    # ------------------------------------------------------------------
    # 阶段2: 初始化源点s
    # ------------------------------------------------------------------
    # 源点标记为已发现（灰色）
    color[s] = "gray"
    # 源点到自身的距离为0
    dist[s] = 0
    # 源点无前驱
    pred[s] = None
    
    # ------------------------------------------------------------------
    # 阶段3: 创建FIFO队列并加入源点
    # ------------------------------------------------------------------
    # 重要：BFS必须使用FIFO队列（先进先出），不能使用优先队列
    # collections.deque是Python的双端队列，popleft()为O(1)，适合BFS
    Q = deque()
    Q.append(s)  # 将源点加入队列尾部
    
    # ------------------------------------------------------------------
    # 阶段4: 主循环——处理队列中的顶点
    # ------------------------------------------------------------------
    while Q:
        # 从队列头部取出顶点u（FIFO顺序）
        u = Q.popleft()
        
        # 遍历u的所有邻居v
        for v in G[u]:
            # 如果邻居v未被访问过（白色）
            if color[v] == "white":
                # 标记为已发现（灰色）
                color[v] = "gray"
                # 距离 = 前驱距离 + 1
                dist[v] = dist[u] + 1
                # 记录前驱为u
                pred[v] = u
                # 将v加入队列尾部（后续处理）
                Q.append(v)
        
        # u的所有邻居处理完毕，标记为已处理（黑色）
        color[u] = "black"
    
    # ------------------------------------------------------------------
    # 阶段5: 返回结果
    # ------------------------------------------------------------------
    return color, dist, pred


# ------------------------------------------------------------------
# 测试用例
# ------------------------------------------------------------------
if __name__ == "__main__":
    # 图的邻接表表示
    # 键为顶点编号，值为邻居列表（无向图）
    G = {
        1: [2, 5],
        2: [1, 6],
        3: [4, 6, 7],
        4: [3, 7, 8],
        5: [1],
        6: [2, 3, 7],
        7: [3, 4, 6, 8],
        8: [4, 7]
    }
    
    # 源点
    s = 2
    
    # 执行BFS
    color, dist, pred = BFS(G, s)
    
    # ------------------------------------------------------------------
    # 打印结果
    # ------------------------------------------------------------------
    print("="*50)
    print(f"BFS从源点 {s} 开始的结果")
    print("="*50)
    
    # 获取所有顶点并排序
    vertices = sorted(G.keys())
    
    print("\n顶点访问状态 (color):")
    for v in vertices:
        print(f"  顶点 {v}: {color[v]}")
    
    print("\n到源点的最短距离 (dist):")
    for v in vertices:
        if dist[v] == math.inf:
            print(f"  顶点 {v}: 不可达")
        else:
            print(f"  顶点 {v}: {int(dist[v])}")
    
    print("\n前驱顶点 (pred) - BFS树:")
    for v in vertices:
        if pred[v] is None:
            if v == s:
                print(f"  顶点 {v}: 源点（无前驱）")
            else:
                print(f"  顶点 {v}: 不可达")
        else:
            print(f"  顶点 {v}: 前驱是 {pred[v]}")
    
    print("\nBFS遍历顺序（按发现顺序）:")
    # 根据距离和发现时间重构遍历顺序
    order = sorted([(v, dist[v]) for v in vertices if dist[v] != math.inf], 
                   key=lambda x: x[1])
    print(" → ".join(str(v[0]) for v in order))
    print("="*50)
```

## 深度优先搜索（DFS）

- 算法步骤
    - 分叉时，任选一条边进行深入
    - 无边时，后退一步找新边
    - 找到边，从新边继续深入
- 辅助数组
    - color
        - white：白色表示尚未被发现
        - black：黑色表示顶点已被处理
        - gray：正在处理，尚未完成
    - pred:顶点 $u$ 由 $pred[u]$ 发现
    - d：顶点发现时刻（变成灰色的时刻）
    - f：顶点完成时刻（变成黑色的时刻）


  <div align="center">
  <img src="./DFS.svg" width="600" alt="DFS" />
  </div>

  - 算法性质
    - 深度优先树：顶点以前驱作为祖先形成的树
    - 边的性质
        - 后向边：不是树边，但两顶点在深度优先树中是祖先后代关系
        - 对于无向图，非树边一定是后向边
    - 点的性质
        - 括号化定理： 点 $v$ 发现时刻和结束时刻构成区间 $[d[v],f[v]]$
        - 任意两点 $v,w$ 必满足以下两种情况
            - $[d[v],f[v]]$ 包含 $[d[w],f[w]]$ , $w$ 是 $v$ 后代
            - $[d[w],f[w]]$ 包含 $[d[v],f[v]]$ , $v$ 是 $w$ 后代
            - $[d[w],f[w]]$ 和 $[d[v],f[v]]$ 完全不重合， $v$ 和 $w$ 均不是对方的后代

    - 路径性质
        - 白色路径定理
            - 在深度优先树中， 顶点 $v$ 是 $w$ 的祖先 等价于在 $v$ 被发现之前，从 $v$ 到 $w$ 存在全为白色的顶点构成的路径

```python
import math

def DFS(G):
    """
    深度优先搜索（DFS）算法 - 计算发现时间和结束时间
    
    参数:
        G: 图的邻接表表示（字典），键为顶点，值为邻居列表
    
    返回:
        pred: 前驱顶点数组（DFS森林）
        d: 发现时刻数组
        f: 结束时刻数组
    """
    # 获取最大顶点编号以确保数组大小足够
    max_vertex = max(G.keys())
    
    # ------------------------------------------------------------------
    # 阶段1: 初始化所有顶点的状态数组
    # ------------------------------------------------------------------
    # color: 访问状态，"white"=未访问, "gray"=已发现, "black"=已处理
    color = ["white"] * (max_vertex + 1)
    
    # pred: 前驱顶点（DFS树中的父节点），None表示无前驱
    pred = [None] * (max_vertex + 1)
    
    # d: 发现时刻（顶点首次被访问的时间），初始化为0
    d = [0] * (max_vertex + 1)
    
    # f: 结束时刻（顶点及其子树处理完毕的时间），初始化为0
    f = [0] * (max_vertex + 1)
    
    # ------------------------------------------------------------------
    # 阶段2: 时间计数器（使用列表实现引用传递）
    # ------------------------------------------------------------------
    # Python中整数是不可变的，为了在递归中正确更新时间，
    # 使用列表time[0]来存储时间戳（列表是可变对象）
    time = [0]
    
    # ------------------------------------------------------------------
    # 阶段3: 遍历所有顶点，处理每个连通分量
    # ------------------------------------------------------------------
    # 从1到max_vertex遍历，确保所有顶点都被访问
    for v in range(1, max_vertex + 1):
        # 如果顶点v存在且未被访问
        if v in G and color[v] == "white":
            # 递归访问顶点v所在的连通分量
            DFS_visit(G, v, color, d, f, pred, time)
    
    # ------------------------------------------------------------------
    # 阶段4: 返回结果
    # ------------------------------------------------------------------
    return pred, d, f


def DFS_visit(G, v, color, d, f, pred, time):
    """
    DFS递归访问函数
    
    参数:
        G: 图的邻接表
        v: 当前访问的顶点
        color: 颜色数组
        d: 发现时间数组
        f: 结束时间数组
        pred: 前驱数组
        time: 时间计数器（列表形式，用于引用传递）
    """
    # ------------------------------------------------------------------
    # 阶段1: 发现顶点v
    # ------------------------------------------------------------------
    # 将顶点标记为灰色（已发现但未处理完毕）
    color[v] = "gray"
    
    # 时间计数器加1
    time[0] += 1
    
    # 记录顶点v的发现时间
    d[v] = time[0]
    
    # ------------------------------------------------------------------
    # 阶段2: 递归访问所有白色邻居
    # ------------------------------------------------------------------
    # 遍历顶点v的所有邻居w
    for w in G[v]:
        # 如果邻居w未被访问（白色）
        if color[w] == "white":
            # 设置w的前驱为v（构建DFS树）
            pred[w] = v
            
            # 递归访问w
            DFS_visit(G, w, color, d, f, pred, time)
    
    # ------------------------------------------------------------------
    # 阶段3: 完成顶点v的处理
    # ------------------------------------------------------------------
    # 将顶点标记为黑色（已处理完毕）
    color[v] = "black"
    
    # 时间计数器加1
    time[0] += 1
    
    # 记录顶点v的结束时间
    f[v] = time[0]


# ------------------------------------------------------------------
# 主程序测试
# ------------------------------------------------------------------
if __name__ == "__main__":
    # 图的邻接表表示（无向图）
    G = {
        1: [2, 5],
        2: [1, 6],
        3: [4, 6, 7],
        4: [3, 7, 8],
        5: [1],
        6: [2, 3, 7],
        7: [3, 4, 6, 8],
        8: [4, 7]
    }
    
    # 从顶点2开始执行DFS
    pred, d, f = DFS(G)
    
    # ------------------------------------------------------------------
    # 打印结果
    # ------------------------------------------------------------------
    print("="*60)
    print("深度优先搜索（DFS）结果 - 从顶点2开始")
    print("="*60)
    
    # 获取所有顶点并排序
    vertices = sorted(G.keys())
    
    print("\n前驱顶点 (pred) - DFS树:")
    for v in vertices:
        if pred[v] is None:
            if v == 2:  # 假设从2开始
                print(f"  顶点 {v}: 根节点")
            else:
                print(f"  顶点 {v}: 不可达")
        else:
            print(f"  顶点 {v}: 前驱是 {pred[v]}")
    
    print("\n发现时间 (d):")
    for v in vertices:
        print(f"  顶点 {v}: {d[v]}")
    
    print("\n结束时间 (f):")
    for v in vertices:
        print(f"  顶点 {v}: {f[v]}")
    
    print("\n括号表示法（区间包含关系）:")
    for v in vertices:
        if d[v] > 0:
            print(f"  {v}: [{d[v]}, {f[v]}]")
    
    print("="*60)
    print(f"最大顶点编号: {max(G.keys())}")
    print(f"数组大小验证: len(pred)={len(pred)}")
    print("="*60)
```

## 有向图的深度优先搜索
- 连通无向图的优先树和有向图的优先森林
    - 无向图
        - 树的形状：取决于搜索顺序
        - 树的数量：确定1棵优先树
        - 树边：在深度优先树中的边
        - 后向边：两顶点有祖先先后代关系的非树边
    - 有向图
        - 树的形状：取决于搜索顺序
        - 树的数量：取决于搜素顺序
        - 树边：在深度优先树中的边
        - 前向边：不在深度优先树中，从祖先指向后代的边
        - 后向边：从后代指向祖先的边
        - 横向边：顶点不具有祖先后代的关系的边
    
```python
def Directed_DFS(G):
    """
    有向图的深度优先搜索(DFS)遍历
    
    参数:
        G: 邻接表表示的有向图，字典类型，键为顶点，值为邻接顶点列表
           例如: {1: [2, 3], 2: [4], 3: [], 4: [1]}
    
    返回:
        pred: 前驱节点数组，记录每个顶点的父节点
        d: 发现时间数组，记录顶点首次被访问的时间戳
        f: 完成时间数组，记录顶点探索完成的时间戳
    """
    # 获取图中所有顶点，确保处理不连续的顶点编号
    all_vertices = set(G.keys()) | {v for neighbors in G.values() for v in neighbors}
    max_vertex = max(all_vertices) if all_vertices else 0
    
    # 初始化访问状态数组（大小为max_vertex+1，支持1-based索引）
    # color: white=未访问, grey=正在访问, black=访问完成
    color = ["white"] * (max_vertex + 1)
    pred = [None] * (max_vertex + 1)      # 前驱节点，用于重构DFS树
    d = [0] * (max_vertex + 1)            # 发现时间（进入时的时间戳）
    f = [0] * (max_vertex + 1)            # 完成时间（结束时的时间戳）
    time = [0]                            # 使用列表实现闭包，便于在递归中修改
    
    # 遍历所有顶点，确保处理非连通图
    for v in range(1, max_vertex + 1):
        if v in G and color[v] == "white":
            # 从每个未访问的顶点启动DFS
            DFS_visit(G, v, color, pred, d, f, time)
    
    return pred, d, f


def DFS_visit(G, v, color, pred, d, f, time):
    """
    DFS递归访问函数
    
    参数:
        G: 图结构
        v: 当前访问的顶点
        color: 访问状态数组
        pred: 前驱节点数组
        d: 发现时间数组
        f: 完成时间数组
        time: 时间戳计数器（使用列表实现引用传递）
    """
    # 标记当前顶点为正在访问（grey）
    color[v] = "grey"
    time[0] += 1
    d[v] = time[0]  # 记录发现时间
    
    # 遍历当前顶点的所有邻接顶点
    for w in G.get(v, []):  # 使用get防止KeyError，处理出度为0的顶点
        if color[w] == "white":
            # 发现未访问的邻接顶点，建立树边
            pred[w] = v
            DFS_visit(G, w, color, pred, d, f, time)
    
    # 当前顶点及其所有后代已探索完成
    color[v] = "black"
    time[0] += 1
    f[v] = time[0]  # 记录完成时间


if __name__ == "__main__":
    # 示例：有向图的邻接表表示
    # 图结构: 1→2, 1→3, 1→4, 2→4, 3→2, 3→5, 4→1, 5无出边
    G = {
        1: [2, 3, 4],
        2: [4],
        3: [2, 5],
        4: [1],
        5: []
    }
    
    # 执行DFS遍历
    pred, d, f = Directed_DFS(G)
    
    # 打印结果
    print("前驱节点:", pred[1:])  # 切片从索引1开始，忽略索引0
    print("发现时间:", d[1:])
    print("完成时间:", f[1:])
```

## 有向图中的环路存在性判断
- 问题定义
    - 输入：有向图 $G=<V,E>$,其中 $V$ 是顶点集合， $E$ 是边的集合
    - 输出：图 $G$ 是否存在环
- 问题观察
    - 树边：在深度优先树中的边
    - 前向边：不管在深度优先树中，从祖先指向后代的边
    - 后向边：从后代指向祖先的边
    - 横向边：顶点不具有祖先后代关系的边

<div align="center">
<img src="./边的分类.svg" width="600" alt="DFS" />
</div>

- 猜想：有向图存在环路 $\iff$ 搜索时出现后向边

<div align="center">
<img src="./有向图判断环.svg" width="600" alt="DFS" />
</div>

```python
from typing import Dict, List

def DFS_Judge_Cycle(G: Dict[int, List[int]]) -> bool:
    """
    使用深度优先搜索(DFS)判断有向图中是否存在环
    
    参数:
        G: 邻接表表示的有向图，字典类型，键为顶点，值为邻接顶点列表
           例如: {1: [2, 3], 2: [4], 3: [], 4: [1]}
    
    返回:
        bool: 若图中存在环返回True，否则返回False
    """
    # 获取图中所有顶点（包括只有入度没有出度的顶点）
    all_vertices = set(G.keys())
    for neighbors in G.values():
        all_vertices.update(neighbors)
    
    if not all_vertices:
        return False  # 空图无环
    
    max_vertex = max(all_vertices)
    
    # color数组标记顶点访问状态：white=未访问, grey=正在访问, black=访问完成
    color = ["white"] * (max_vertex + 1)
    
    # 对每个未访问的顶点启动DFS（处理非连通图）
    for v in range(1, max_vertex + 1):
        if v in all_vertices and color[v] == "white":
            if DFS_visit_Judge_Cycle(G, v, color):
                return True  # 发现环立即返回
    
    return False  # 所有顶点处理完毕未发现环


def DFS_visit_Judge_Cycle(G: Dict[int, List[int]], v: int, color: List[str]) -> bool:
    """
    DFS递归访问函数，检测从顶点v出发的路径中是否存在环
    
    参数:
        G: 图结构
        v: 当前访问的顶点
        color: 访问状态数组
    
    返回:
        bool: 若从v出发的子图中找到环返回True
    """
    # 标记当前顶点为正在访问（grey）
    # 如果之后在递归过程中再次访问到grey顶点，说明存在回边，即存在环
    color[v] = "grey"
    
    # 遍历当前顶点的所有邻接顶点
    for neighbor in G.get(v, []):  # 使用get避免KeyError
        if color[neighbor] == "grey":
            # 关键检测：发现邻接顶点正在访问中，说明找到了回边
            # 这表示存在一条从neighbor到v的路径，现在又有一条从v到neighbor的边
            # 构成了有向环
            return True
        
        if color[neighbor] == "white":
            # 邻接顶点未访问过，递归深入
            # 如果递归返回True，说明在子图中找到环，向上传播
            if DFS_visit_Judge_Cycle(G, neighbor, color):
                return True
    
    # 当前顶点及其所有后代已探索完成，标记为black
    color[v] = "black"
    return False  # 从当前顶点未找到环


# 测试用例
if __name__ == "__main__":
    # 示例：包含环的有向图 1→2→4→5→3→1（形成环1-2-5-3-1）
    G_with_cycle = {
        1: [2],
        2: [4],
        3: [1],
        4: [5],
        5: [3]
    }
    print("图G是否有环?", DFS_Judge_Cycle(G_with_cycle))  
```

## 拓扑排序
- 问题定义
    - 输入：有向无环图 $G=<V,E>$
    - 输出：图顶点 $V$ 的拓扑排序 $S$,满足对于任意有向边 $(u,v)$,排序之后 $u$ 在 $v$ 之前
- 广度优先搜索策略
    - 有向图顶点的度分为入度和出度
        - 顶点 $u$ 的入度： 终点为 $u$ 的边数
        - 顶点 $u$ 的出度： 起点为 $u$ 的边数
    - 若顶点的入度是0：所对应事件无制约，可直接完成

<div align="center">
<img src="./Topological-Sort-BFS.svg" width="600" alt="DFS" />
</div>

```python
from collections import deque

def Topological_Sort_BFS(G):
    """
    使用Kahn算法（BFS版本）实现拓扑排序
    
    参数:
        G: 有向无环图(DAG)的邻接表表示，字典类型
           键为顶点，值为该顶点指向的邻居列表
    
    返回:
        list: 拓扑排序结果列表，顶点按依赖顺序排列
              若图中存在环则返回空列表
    """
    # 初始化入度字典：记录每个顶点的入度（依赖数量）
    in_degree = {vertex: 0 for vertex in G}
    
    # 计算所有顶点的实际入度
    # 遍历图的每条边 (u -> v)，增加v的入度
    for vertex in G:
        for neighbor in G[vertex]:
            # 确保邻居顶点在字典中（处理只有入度没有出度的顶点）
            if neighbor not in in_degree:
                in_degree[neighbor] = 0
            in_degree[neighbor] += 1
    
    # 初始化队列：将所有入度为0的顶点加入队列
    # 这些顶点是没有任何依赖的起点，可以立即处理
    Q = deque()
    for vertex in G:
        if in_degree[vertex] == 0:
            Q.append(vertex)
    
    # 存储拓扑排序的结果
    result = []
    
    # 处理队列：不断取出没有依赖的顶点
    while Q:
        u = Q.popleft()  # 从队列左侧弹出，保证FIFO顺序
        result.append(u)  # 将顶点加入结果列表
        
        # 遍历u的所有邻居顶点v
        # 移除边u->v后，v的入度减1
        for v in G.get(u, []):
            in_degree[v] -= 1
            # 如果v的入度变为0，说明其所有依赖已处理完
            # 可以加入队列进行处理
            if in_degree[v] == 0:
                Q.append(v)
    
    # 检测图中是否存在环
    # 如果结果列表长度小于图中顶点总数，说明有环
    if len(result) != len(in_degree):
        print("警告：图中存在环，无法完成拓扑排序")
        return []
    
    return result


# 示例：穿衣顺序的依赖关系图
# 边表示"必须在...之前"，如"袜子" -> "鞋" 表示先穿袜子再穿鞋
G = {
    "袜子": ["鞋"],          # 袜子必须在鞋之前
    "鞋": [],                # 鞋没有依赖
    "手表": [],              # 手表没有依赖
    "衬衫": ["腰带", "领带"], # 衬衫必须在腰带和领带之前
    "短裤": ["长裤", "鞋"],   # 短裤必须在长裤和鞋之前
    "长裤": ["腰带"],         # 长裤必须在腰带之前
    "腰带": ["外套"],         # 腰带必须在外套之前
    "领带": ["外套"],         # 领带必须在外套之前
    "外套": []               # 外套没有依赖
}

# 执行拓扑排序
sorted_order = Topological_Sort_BFS(G)

# 打印结果
if sorted_order:
    print("拓扑排序结果:", sorted_order)
    print("\n一个有效的穿衣顺序（从头到尾）:")
    for i, item in enumerate(sorted_order, 1):
        print(f"{i}. {item}")
```

- 深度优先搜索策略
    - 从DFS视角进行观察
        - 深度越深，顺序越靠后
            - 完成时刻越早：按照完成时刻逆序

<div align="center">
<img src="./Topological-Sort-DFS.svg" width="600" alt="DFS" />
</div>

```python
def Topological_Sort_DFS(G):
    """
    基于DFS的拓扑排序算法
    
    参数:
        G: 有向无环图(DAG)的邻接表表示，字典类型
           键为顶点(字符串)，值为该顶点指向的邻居列表
           例如: {"A": ["B", "C"], "B": ["D"], "C": [], "D": []}
    
    返回:
        list: 拓扑排序结果，顶点按依赖顺序排列
              若图中存在环，则可能无法生成完全正确的拓扑序
    """
    # 初始化访问状态字典: white=未访问, gray=正在访问, black=访问完成
    color = {vertex: "white" for vertex in G}
    
    # 存储拓扑排序结果
    L = []
    
    # 遍历图中所有顶点
    for vertex in G:
        if color[vertex] == "white":
            # 从每个未访问的顶点启动DFS
            DFS_visit(G, vertex, color, L)
    
    # 返回拓扑排序结果（已完成后序遍历的顶点列表）
    return L


def DFS_visit(G, v, color, L):
    """
    DFS访问函数，采用后序遍历收集顶点
    
    参数:
        G: 图结构
        v: 当前访问的顶点
        color: 访问状态字典
        L: 拓扑排序结果列表（引用传递）
    """
    # 标记当前顶点为正在访问（gray），用于环检测
    color[v] = "gray"
    
    # 遍历当前顶点的所有邻居
    for w in G[v]:
        if color[w] == "white":
            # 递归访问未访问的邻居
            DFS_visit(G, w, color, L)
        elif color[w] == "gray":
            # 如果遇到正在访问的节点，说明存在环（拓扑排序不适用）
            # 在实际应用中应抛出异常或处理该情况
            raise ValueError(f"图中存在环，检测到反向边: {v} -> {w}")
    
    # 当前顶点及其所有后代已探索完成，标记为black
    color[v] = "black"
    
    # 将顶点加入结果列表（后序遍历: 先处理完所有依赖再添加自己）
    # 这保证了依赖项总在当前顶点之前
    L.append(v)


# 示例：穿衣顺序的依赖关系图
# 边表示"必须在...之前穿"，如"袜子" -> "鞋" 表示必须先穿袜子再穿鞋
G = {
    "袜子": ["鞋"],          # 袜子必须在鞋之前
    "鞋": [],                # 鞋没有依赖
    "手表": [],              # 手表没有依赖
    "衬衫": ["腰带", "领带"], # 衬衫必须在腰带和领带之前
    "短裤": ["长裤", "鞋"],   # 短裤必须在长裤和鞋之前
    "长裤": ["腰带"],         # 长裤必须在腰带之前
    "腰带": ["外套"],         # 腰带必须在外套之前
    "领带": ["外套"],         # 领带必须在外套之前
    "外套": []               # 外套没有依赖
}

try:
    # 执行拓扑排序
    result = Topological_Sort_DFS(G)
    
    # 打印结果（从后往前读更符合依赖关系）
    print("拓扑排序结果（逆序）:", result)
    print("正确穿衣顺序（从头到尾）:", list(reversed(result)))
except ValueError as e:
    print("错误:", e)
```


## 强连通分量

- 问题背景与定义
    - 问题背景：社交圈的划分，如何按照人群通话记录划分为不同的社交圈
    - 强连通分量
        - 一个强连通分量是顶点的子集
        - 强连通分量中任意两点可以相互可达
        - 满足最大性：加入新顶点，不保证相互可达
    - 问题定义：
        - 输入：有向图 $G=<V,E>$
        - 输出：图的所有的强连通分量 $C_1,C_2,....,C_n$


- 算法框架与实例
    - 步骤：
        - 1.把边反向，得到反向图 $G^R$
        - 2.在 $G^R$ 上执行DFS,得到顶点完成时刻顺序 $L$
        - 3.在 $G$ 按 $L$ 逆序执行DFS,得到强连通分量

- 伪代码与复杂度

<div align="center">
<img src="./Strongly-Connected-Component.svg" width="600" alt="DFS" />
</div>

```python
from collections import defaultdict

def Strongly_Connected_Component(G):
    """
    Kosaraju算法：计算有向图的强连通分量(SCC)
    
    参数:
        G: 有向图的邻接表表示，字典类型
           键为顶点，值为该顶点指向的邻居列表
    
    返回:
        list: 强连通分量列表，每个分量是一个顶点集合
    """
    # 第一步：对原图G进行DFS，获取顶点的完成时间顺序
    visited = set()
    finish_order = []  # 按完成时间排序的顶点列表（后序遍历）
    
    def dfs_first(v):
        """第一次DFS：计算完成时间"""
        visited.add(v)
        for w in G.get(v, []):
            if w not in visited:
                dfs_first(w)
        # 顶点探索完成后，将其加入列表（后序遍历）
        finish_order.append(v)
    
    # 遍历所有顶点
    for vertex in G:
        if vertex not in visited:
            dfs_first(vertex)
    
    # 第二步：构建反向图GR
    GR = defaultdict(list)
    for u in G:
        for v in G[u]:
            GR[v].append(u)  # 将边u->v反转为v->u
    
    # 第三步：按完成时间逆序对反向图进行DFS
    visited.clear()
    scc_components = []  # 存储所有强连通分量
    
    def dfs_second(v, component):
        """第二次DFS：在反向图中探索SCC"""
        visited.add(v)
        component.append(v)
        for w in GR.get(v, []):
            if w not in visited:
                dfs_second(w, component)
    
    # 按照完成时间的逆序遍历顶点
    for vertex in reversed(finish_order):
        if vertex not in visited:
            component = []
            dfs_second(vertex, component)
            scc_components.append(component)
    
    return scc_components


def DFS(G):
    """
    辅助函数：返回按完成时间排序的顶点列表
    （用于Kosaraju算法的第一步）
    """
    visited = set()
    finish_order = []
    
    def dfs_visit(v):
        visited.add(v)
        for w in G.get(v, []):
            if w not in visited:
                dfs_visit(w)
        finish_order.append(v)
    
    for vertex in G:
        if vertex not in visited:
            dfs_visit(vertex)
    
    return finish_order


# 示例图：包含多个强连通分量
# 1,10,3,4构成一个SCC；2,5,6构成一个SCC；7自成一个SCC；8,9构成一个SCC
G = {
    1: [10, 3],
    2: [6],
    3: [4, 7],
    4: [1, 6],
    5: [2],
    6: [5],
    7: [7],
    8: [9, 10],
    9: [7, 8],
    10: [1]
}

# 计算并打印强连通分量
scc_list = Strongly_Connected_Component(G)
print(f"图中共有 {len(scc_list)} 个强连通分量:")
for i, component in enumerate(scc_list, 1):
    print(f"SCC {i}: {component}")
```


## 最小生成树
- 问题背景
    - 需要修建道路来连通城市，各道路花费不同
    - 问题：连通各城市的最小花费是多少

- 概念回顾
    - 生成子图
        - 子图：如果 $V{'} \subseteq V$ , $E^{'} \subseteq E$ ，则称图 $G^{'} =<V^{'},E^{'}>$ 是图 $G$ 的一个子图
        - 生成子图：如果 $V^{'} \subseteq V $ , $E^{'} \subseteq E$,则称图 $G^{'}=<V^{'},E^{'}>$是图 $G$ 的一个生成子图
    - 生成树
        - 图 $T^{'}=<V^{'}.E^{'}>$ 是无向图 $G$ 的一个生成子图，并且是连通的、无环路的(树)
- 问题定义
    - 输入：连通无向图 $G=<V,E,W>$,其中$w(u,v)\in W$表示边$(u,v)$的权重
    - 输出：图$G$的最小生成树 
    $T=<V_T,E_T>$

    $$
    \min\sum_{e\in E_T}w(e)\\
    s.t. V_T=V,E_T\subseteq E
    $$

- 通用框架
    - 生成树是一个无向图中的连通、无环的生成子图
        - 新建一个空边集$A$，边集$A$可以扩展为最小生成树
        - 每次向边集$A$中增加一条边
            - 需要保证边集A仍是一个无环图
            - 需要保证边集A仍是最小生成树子集
    - 如何保证边集A是最小生成树子集
        - 安全边
            - A是某棵最小生成树T边的子集，$A \subseteq T$
            - $A\cup \{(u,v)\}$仍是$T$边的一个子集，称$(u,v)$是 $A$ 的安全边
        - 割
            - 图 $G=<V,E>$ 是一个连通无向图，割 $(S,V-S)$ 将图 $G$ 的顶点集 $V$ 划分为两部分
        - 横跨
            - 给定割 $(S,V-S)$和边 $(u,v)$,$u\in S$,$v\in V-S$，称边 $(u,v)$ 横跨割 $(S,V-S)$
        - 轻边
            - 横跨割的所有边中，权重最小的称为横跨这个割的一条轻边
        - 不妨害    
            - 如果一个边集A中没有边横跨某割，则成为该割不妨害边集$A$

- Prim算法
    - 算法思想
        - 1.选择任意一个顶点，作为生成树的起始顶点
        - 2.保持边集 $A$始终为一棵树，选择割 $(V_A,V-V_A)$
        - 3.选择横跨割 $(V_A,V-V_A)$ 的轻边
        - 4.重复步骤2和步骤3，直至覆盖所有的顶点
    - 辅助数组
        - color 
            - 黑色顶点$u$已覆盖， $u\in V_A$
            - 白色顶点$u$未覆盖， $u\in V-V_A$
        - dist记录横跨 $V_A,V-V_A$边的权重
            - 顶点集 $V_A$到顶点 $u$ 的最短距离，$dist[u]=\min(\{w(x,u)\}),\forall x\in V_A$
            - 轻边： $\min{\{dist[u]\}},\forall u\in V-V_A$
        - pred表示前驱顶点
            - （$pred[u],u$）为最小生成树的边

- 伪代码

<div align="center">
<img src="./Prim.svg" width="600" alt="DFS" />
</div>

```python
# prim算法
import numpy as np
from collections import defaultdict

def MST_Prim(G):
    """
    Prim算法：求无向连通带权图的最小生成树(MST)
    适用于顶点为字符串的图结构
    
    参数:
        G: 图的邻接表表示，字典的字典结构
           外层键是顶点，内层键是邻居顶点，值是边权重
    
    返回:
        tuple: (mst_edges, total_weight)
               mst_edges: MST边的列表，格式为[(起点, 终点, 权重), ...]
               total_weight: 最小生成树的总权重
    """
    if not G:
        return [], 0
    
    # 获取所有顶点
    vertices = list(G.keys())
    if not vertices:
        return [], 0
    
    # 初始化访问状态、距离数组和前驱节点
    # 使用字典结构支持字符串顶点
    color = {v: "white" for v in vertices}  # white=未访问, black=已加入MST
    dist = {v: np.inf for v in vertices}    # 各顶点到当前MST的最短距离
    pred = {v: None for v in vertices}      # 前驱节点
    
    # 任选一个起始顶点
    start = vertices[0]
    dist[start] = 0
    mst_edges = []      # 存储MST的边
    total_weight = 0    # MST的总权重
    
    # 主循环：直到所有顶点都被加入MST
    for _ in range(len(vertices)):
        # 第一步：在还未加入MST的顶点中，选择dist最小的顶点
        min_dist = np.inf
        rec = None  # 记录当前选中的顶点
        
        for v in vertices:
            if color[v] != "black" and dist[v] < min_dist:
                min_dist = dist[v]
                rec = v
        
        # 如果没有找到可达顶点（图不连通）
        if rec is None:
            print("警告：图不连通，无法生成完整的最小生成树")
            break
        
        # 将选中的顶点加入MST
        color[rec] = "black"
        if pred[rec] is not None:
            mst_edges.append((pred[rec], rec, dist[rec]))
            total_weight += dist[rec]
        
        # 第二步：更新rec的所有邻居的距离
        for u in G.get(rec, {}):
            # 如果邻居u还未加入MST，且新边权重更小
            if color[u] != "black" and G[rec][u] < dist[u]:
                dist[u] = G[rec][u]
                pred[u] = rec
    
    return mst_edges, total_weight


# 测试图（无向带权图，注意大小写统一）
G = {
    "a": {"b": 4, "h": 8},
    "b": {"a": 4, "h": 1, "c": 8},
    "c": {"b": 8, "i": 2, "h": 4, "d": 7},  # 修复：统一为"c"小写
    "d": {"c": 7, "f": 14, "z": 9},
    "f": {"g": 2, "c": 4, "d": 14, "z": 10},
    "g": {"h": 1, "i": 4, "f": 2},
    "h": {"a": 8, "b": 1, "i": 7, "g": 1},
    "i": {"c": 2, "h": 7, "g": 4},
    "z": {"d": 9, "f": 10}  # 添加了"z"的出边（双向图）
}

# 执行Prim算法
mst_edges, total_weight = MST_Prim(G)

# 打印结果
print("最小生成树的边:")
for edge in mst_edges:
    print(f"  {edge[0]} - {edge[1]} : 权重 {edge[2]}")

print(f"\n最小生成树总权重: {total_weight}")
```

- 数据结构：优先队列
    - 队列中每个元素有一个关键字，依据关键字大小离开队列
    - 通过二叉堆来实现优先队列

```python
# 优先队列
import numpy as np
import heapq
from collections import defaultdict

def MST_Prim_PriQueue(G):
    """
    Prim算法：使用优先队列（最小堆）实现的最小生成树算法
    
    参数:
        G: 无向带权图的邻接表表示，字典的字典结构
           外层键是顶点，内层键是邻居顶点，值是边权重
    
    返回:
        tuple: (mst_edges, total_weight)
               mst_edges: MST边的列表，格式为(起点, 终点, 权重)
               total_weight: 最小生成树的总权重
    """
    if not G:
        return [], 0
    
    # 获取所有顶点
    vertices = list(G.keys())
    if not vertices:
        return [], 0
    
    # 初始化访问状态、距离数组和前驱节点
    color = {v: "white" for v in vertices}  # white=未访问, black=已加入MST
    dist = {v: np.inf for v in vertices}    # 各顶点到当前MST的最短距离
    pred = {v: None for v in vertices}      # 前驱节点
    
    # 任选一个起始顶点
    start = vertices[0]
    dist[start] = 0
    
    # 优先队列：(距离, 顶点)，按照距离排序
    # Python的heapq实现的是最小堆
    pq = [(0, start)]  # (当前顶点加入MST所需的最小边权重, 顶点)
    
    mst_edges = []      # 存储MST的边
    total_weight = 0    # MST的总权重
    
    # 主循环：直到所有顶点都被加入MST
    while pq:
        # 弹出距离最小的顶点
        current_dist, v = heapq.heappop(pq)
        
        # 如果该顶点已处理过，跳过（避免重复入队）
        if color[v] == "black":
            continue
        
        # 将顶点加入MST
        color[v] = "black"
        if pred[v] is not None:
            mst_edges.append((pred[v], v, current_dist))
            total_weight += current_dist
        
        # 更新v的所有邻居的距离
        for u, weight in G.get(v, {}).items():
            # 如果邻居未访问且新边权重更小
            if color[u] == "white" and weight < dist[u]:
                dist[u] = weight
                pred[u] = v
                # 将邻居加入优先队列
                heapq.heappush(pq, (weight, u))
    
    # 检查图是否连通
    if len([v for v in vertices if color[v] == "black"]) != len(vertices):
        print("警告：图不连通，无法生成完整的最小生成树")
    
    return mst_edges, total_weight


# 测试图（无向带权图，注意大小写统一）
G = {
    "a": {"b": 4, "h": 8},
    "b": {"a": 4, "h": 1, "c": 8},
    "c": {"b": 8, "i": 2, "h": 4, "d": 7},
    "d": {"c": 7, "f": 14, "z": 9},
    "f": {"g": 2, "c": 4, "d": 14, "z": 10},
    "g": {"h": 1, "i": 4, "f": 2},
    "h": {"a": 8, "b": 1, "i": 7, "g": 1},
    "i": {"c": 2, "h": 7, "g": 4},
    "z": {"d": 9, "f": 10}
}

# 执行Prim算法
mst_edges, total_weight = MST_Prim_PriQueue(G)

# 打印结果
print("最小生成树的边:")
for edge in mst_edges:
    print(f"  {edge[0]} - {edge[1]} : 权重 {edge[2]}")

print(f"\n最小生成树总权重: {total_weight}")
```



## 最小生成树Kruskal算法
- 问题定义
    - 输入：连通无向图 $G=<V,E,W>$,其中 $w(u,v)\in W$表示边 $(u,v)$的权重
    - 输出：图 $G$的最小生成树 $T=<V_T,E_T>$
$$
\min{\sum_{e\in E_T}w(e)}\\
s.t. V_T=V,E_T\in E
$$
- 算法与实例
    - 算法思想：直接使用通用框架
        - 保证边集合 $A$ 是一个无环图（选边的时避免成环）
        - 保证边集合 $A$ 仍是最小生成树的子集（每次选择当前权重最小的边）

<div align="center">
<img src="./MST-Kruskal.svg" width="600" alt="DFS" />
</div>

```python
# Kruskal算法
from collections import defaultdict

class UnionFind:
    """并查集数据结构"""
    def __init__(self, vertices):
        self.parent = {v: v for v in vertices}
        self.rank = {v: 0 for v in vertices}
    
    def find(self, x):
        """查找根节点，带路径压缩"""
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        """合并两个集合"""
        root_x = self.find(x)
        root_y = self.find(y)
        
        if root_x == root_y:
            return False  # 已经在同一集合，形成环
        
        # 按秩合并
        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
        elif self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
        else:
            self.parent[root_y] = root_x
            self.rank[root_x] += 1
        
        return True  # 成功合并

def MST_Kruskal(G):
    """
    Kruskal算法：求最小生成树
    
    参数:
        G: 无向带权图的邻接表表示
    
    返回:
        tuple: (mst_edges, total_weight)
    """
    # 1. 获取所有边并排序
    edges = sort_edges_by_weight(G)
    
    # 2. 初始化并查集和结果
    uf = UnionFind(G.keys())
    mst_edges = []
    total_weight = 0
    
    # 3. 遍历排序后的边
    for weight, u, v in edges:
        # 如果u和v不在同一连通分量（不形成环）
        if uf.union(u, v):
            mst_edges.append((u, v, weight))
            total_weight += weight
    
    return mst_edges, total_weight

def sort_edges_by_weight(G):
    """按权重升序排列所有边"""
    edges = []
    seen = set()
    
    for u in G:
        for v, weight in G[u].items():
            edge_key = tuple(sorted([u, v]))
            if edge_key not in seen:
                seen.add(edge_key)
                edges.append((weight, u, v))
    
    edges.sort(key=lambda x: x[0])
    return edges

# 测试图
G = {
    "a": {"b": 4, "h": 8},
    "b": {"a": 4, "h": 1, "c": 8},
    "c": {"b": 8, "i": 2, "h": 4, "d": 7},
    "d": {"c": 7, "f": 14, "z": 9},
    "f": {"g": 2, "c": 4, "d": 14, "z": 10},
    "g": {"h": 1, "i": 4, "f": 2},
    "h": {"a": 8, "b": 1, "i": 7, "g": 1},
    "i": {"c": 2, "h": 7, "g": 4},
    "z": {"d": 9, "f": 10}
}

# 执行Kruskal算法
mst_edges, total_weight = MST_Kruskal(G)

# 打印结果
print("最小生成树的边:")
for edge in mst_edges:
    print(f"  {edge[0]} - {edge[1]} : 权重 {edge[2]}")

print(f"\n最小生成树总权重: {total_weight}")
```

- 不相交集合
    - 把每棵生成子树看作一个顶点的集合
        - 每个集合表示为一颗有向树，多个不相交集合构成不相交集合森林
        - 集合元素表示为树的节点
        - 树边由子结点指向父节点，根结点有一条指向自身的边
    - 初始化集合：创建根结点，并设置一条指向自身的边
    - 判定顶点是否在同一集合：回溯查找树根，检查树根是否相同
    - 合并集合：合并两棵树

```python
# Union
from collections import defaultdict

class UnionFind:
    """并查集数据结构"""
    def __init__(self, vertices):
        self.parent = {v: v for v in vertices}
        self.rank = {v: 0 for v in vertices}
    
    def find(self, x):
        """查找根节点，带路径压缩"""
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        """合并两个集合"""
        root_x = self.find(x)
        root_y = self.find(y)
        
        if root_x == root_y:
            return False  # 已经在同一集合，形成环
        
        # 按秩合并
        if self.rank[root_x] < self.rank[root_y]:
            self.parent[root_x] = root_y
        elif self.rank[root_x] > self.rank[root_y]:
            self.parent[root_y] = root_x
        else:
            self.parent[root_y] = root_x
            self.rank[root_x] += 1
        
        return True  # 成功合并
```

<div align="center">
<img src="./MST-Kruskal-union.svg" width="600" alt="DFS" />
</div>



| | Prim算法 | Kruskal算法 |
|---------|---------|---------|
| 核心思想   | 保持一棵树，不断扩展   | 子树森林，合并为一棵树 |
| 数据结构   | 优先队列  |  不相交集合 | 
| 求解视角   | 微观视角，基于当前点选边 | 宏观视角，基于全局顺序选边 |
| 算法策略   |都是采用贪心策略的图算法 |
## 单源最短路径问题Dijkstra算法
- 问题定义
    - 输入
        - 带权图 $G=<V,E,W>$ ，其中 $w(u,v)\geq 0$(图中所有边权为正)，$(u,v)\in E$
        - 源点编号 $s$

    - 输出
        - 源点 $s$ 到所有其他的顶点 $t$的最短距离$\delta(s,t)$和最短路径 $<s,...t>$
- 算法思想
    - 辅助数组
        - dist表示距离上界(估计距离)
            - 源点 $s$ ,$dist[s]=0$,其他顶点 $u$ ,$dist[u]$ 初始化为$\inf$
            - $dist[u]$:源点 $s$到顶点 $u$的距离上界， $\delta (s,u)\leq dist[u]$
        - color 表示顶点的状态
            - 黑色：到顶点 $u$ 的最短距离已被确定
            - 白色：到顶点 $u$ 最短路尚未被确定
        - pred表示前驱顶点
            - $(pred[u],u)$表示最短路径上的边
    - 算法思想
        - 1.新建空的黑色顶点集合 $V_A$
        - 2.选择一个空白顶点变为黑色(到该顶点最短路被确定)
        - 3.重复步骤2，直至所有的顶点均为黑色

- 算法分析
<div align="center">
<img src="./Dijkstra.svg" width="600" alt="DFS" />
</div>

```python
#dijkstra
import numpy as np
from collections import defaultdict

def Dijkstra(G, source=None):
    """
    Dijkstra算法：单源最短路径
    
    参数:
        G: 带权有向图，邻接表表示，格式为 {顶点: {邻居: 权重}}
        source: 源顶点，默认为图的第一个顶点
    
    返回:
        tuple: (dist, pred)
               dist: 从源点到各顶点的最短距离字典
               pred: 前驱节点字典，用于重构路径
    """
    if not G:
        return {}, {}
    
    # 获取所有顶点
    vertices = list(G.keys())
    if source is None:
        source = vertices[0]
    
    # 初始化
    color = {v: "white" for v in vertices}  # white=未访问, black=已确定最短距离
    pred = {v: None for v in vertices}       # 前驱节点
    dist = {v: np.inf for v in vertices}     # 当前最短距离估计
    dist[source] = 0                         # 源点到自身距离为0
    
    # 主循环：处理所有顶点
    for _ in range(len(vertices)):
        # 第一步：在所有未访问顶点中，选择dist最小的顶点
        rec = None  # 记录当前选中的顶点
        min_dist = np.inf
        
        for v in vertices:
            if color[v] != "black" and dist[v] < min_dist:
                min_dist = dist[v]
                rec = v
        
        # 如果没有可达顶点（图不连通）
        if rec is None or min_dist == np.inf:
            break
        
        # 标记该顶点为已访问（已确定最终最短距离）
        color[rec] = "black"
        
        # 第二步：更新rec的所有邻居的距离
        for u, weight in G.get(rec, {}).items():
            # 如果通过rec到u的路径更短，则更新
            if color[u] != "black" and dist[rec] + weight < dist[u]:
                dist[u] = dist[rec] + weight
                pred[u] = rec
    
    return dist, pred


# 测试图（有向带权图）
G = {
    "s": {"t": 8, "y": 5},
    "t": {"x": 1, "y": 2},
    "x": {"z": 4},
    "y": {"t": 3, "x": 9, "z": 2},
    "z": {"x": 6}
}

# 执行Dijkstra算法，源点为"s"
distances, predecessors = Dijkstra(G, source="s")

# 打印结果
print("从源点's'出发的最短距离:")
for vertex in sorted(G.keys()):
    print(f"  到 {vertex}: 距离 = {distances[vertex]}")

print("\n前驱节点（用于重构路径）:")
for vertex in sorted(G.keys()):
    if predecessors[vertex] is not None:
        print(f"  {vertex} <- {predecessors[vertex]}")
    else:
        print(f"  {vertex} <- None (源点)")

# 示例：重构从s到z的路径
def reconstruct_path(pred, source, target):
    """重构从source到target的最短路径"""
    if pred[target] is None and target != source:
        return f"从{source}到{target}没有路径"
    
    path = []
    current = target
    while current is not None:
        path.append(current)
        if current == source:
            break
        current = pred.get(current)
    
    return " -> ".join(reversed(path))

print(f"\n从s到z的最短路径: {reconstruct_path(predecessors, 's', 'z')}")
```


<div align="center">
<img src="./Dijkstra-PriQueu.svg" width="600" alt="DFS" />
</div>

```python
#dijkstra 优先队列
import heapq
import numpy as np
from collections import defaultdict

def Dijkstra_PriQueue(G, source):
    """
    Dijkstra算法：使用优先队列优化的单源最短路径
    
    参数:
        G: 带权有向图，邻接表表示，格式为 {顶点: {邻居: 权重}}
        source: 源顶点
    
    返回:
        tuple: (dist, pred)
               dist: 从源点到各顶点的最短距离字典
               pred: 前驱节点字典，用于重构路径
    """
    if not G or source not in G:
        return {}, {}
    
    # 获取所有顶点（包括只有入边的顶点）
    all_vertices = set(G.keys())
    for neighbors in G.values():
        all_vertices.update(neighbors.keys())
    
    # 初始化
    color = {v: "white" for v in all_vertices}  # white=未访问, black=已确定最短距离
    pred = {v: None for v in all_vertices}       # 前驱节点
    dist = {v: np.inf for v in all_vertices}     # 当前最短距离估计
    dist[source] = 0                             # 源点到自身距离为0
    
    # 优先队列：(当前距离, 顶点)，按距离排序
    pq = [(0, source)]
    
    # 主循环
    while pq:
        current_dist, v = heapq.heappop(pq)
        
        # 如果该顶点已处理过，跳过（避免重复处理）
        if color[v] == "black":
            continue
        
        # 标记为已访问（最短距离已确定）
        color[v] = "black"
        
        # 遍历v的所有邻居
        for u, weight in G.get(v, {}).items():
            # 如果找到更短的路径，则更新
            if color[u] != "black" and dist[v] + weight < dist[u]:
                dist[u] = dist[v] + weight
                pred[u] = v
                # 将邻居加入优先队列
                heapq.heappush(pq, (dist[u], u))
    
    return dist, pred


def reconstruct_path(pred, source, target):
    """
    重构从source到target的最短路径
    
    参数:
        pred: 前驱节点字典
        source: 源顶点
        target: 目标顶点
    
    返回:
        str: 路径字符串或错误信息
    """
    if pred.get(target) is None and target != source:
        return f"从{source}到{target}没有路径"
    
    path = []
    current = target
    while current is not None:
        path.append(current)
        if current == source:
            break
        current = pred.get(current)
    
    if path[-1] != source:
        return f"从{source}到{target}没有完整路径"
    
    return " -> ".join(reversed(path))


# 测试图（有向带权图）
G = {
    "s": {"t": 8, "y": 5},
    "t": {"x": 1, "y": 2},
    "x": {"z": 4},
    "y": {"t": 3, "x": 9, "z": 2},
    "z": {"x": 6}
}

# 执行Dijkstra算法，源点为"s"
distances, predecessors = Dijkstra_PriQueue(G, source="s")

# 打印结果
print("从源点's'出发的最短距离:")
for vertex in sorted(G.keys()):
    print(f"  到 {vertex}: 距离 = {distances[vertex]}")

print("\n前驱节点（用于重构路径）:")
for vertex in sorted(G.keys()):
    if predecessors[vertex] is not None:
        print(f"  {vertex} <- {predecessors[vertex]}")
    else:
        print(f"  {vertex} <- None (源点)")

# 示例：重构从s到x的最短路径
print(f"\n从s到x的最短路径: {reconstruct_path(predecessors, 's', 'x')}")
print(f"从s到z的最短路径: {reconstruct_path(predecessors, 's', 'z')}")

# 验证算法正确性：检查s到x的路径
# 预期：s(0) -> y(5) -> t(5+3=8) -> x(8+1=9)
# 实际输出应为9
assert abs(distances['x'] - 9) < 0.001, "s到x的距离应为9"
```

## 单源最短路径问题Bellman-Ford算法
- 问题定义
    - 输入：1.带权图 $G = <V,E,W>$,2.源点编号 $s$
    - 输出：1.源点 $s$ 到所有其他顶点 $t$ 的最短距离 $\delta(s,t)$ 和最短路径 $<s,...t>$ 2.存在源点 $s$ 可达的负环
- 算法思想
    - 对图中存在负权边的时候，每轮对所有的边进行松弛，持续迭代 $|V|-1$轮
    - 对于图中存在源点可达负环，如果第$|V|$轮松弛成功，存在源点 $s$ 可达的负环

<div align="center">
<img src="./bellman-Ford.svg" width="600" alt="DFS" />
</div>

```python
# Bellman-Ford
import numpy as np

def Bellman_Ford(G, s):
    """
    Bellman-Ford算法：单源最短路径算法，支持负权边，能检测负环
    
    参数:
        G: 带权有向图，邻接表表示，格式为 {顶点: {邻居: 权重}}
        s: 源顶点
    
    返回:
        tuple: (dist, pred)
               dist: 从源点到各顶点的最短距离字典
               pred: 前驱节点字典，用于重构路径
               如果检测到负环，返回 (None, None)
    """
    if s not in G:
        return {}, {}
    
    # 获取所有顶点（包括只有入边的顶点）
    vertices = set(G.keys())
    for neighbors in G.values():
        vertices.update(neighbors.keys())
    
    # 初始化距离和前驱
    dist = {v: np.inf for v in vertices}  # 到各顶点的最短距离
    pred = {v: None for v in vertices}    # 前驱节点
    dist[s] = 0                           # 源点到自身距离为0
    
    # 提取所有边，格式为(起点, 终点, 权重)
    edges = []
    for u in G:
        for v, weight in G[u].items():
            edges.append((u, v, weight))
    
    # 主循环：对所有边进行 |V|-1 次松弛操作
    # 原理：每次松弛都会使某些顶点的最短距离变得更优
    # 进行 |V|-1 次可以确保所有顶点的最短距离最终确定
    for _ in range(len(vertices) - 1):
        # 遍历每条边 (u, v)
        for u, v, weight in edges:
            # 如果通过u到v的路径更短，则更新dist和pred
            # 这就是松弛操作的核心
            if dist[u] + weight < dist[v]:
                dist[v] = dist[u] + weight
                pred[v] = u
    
    # 负环检测：再进行一次遍历
    # 如果还能松弛，说明存在负权环
    for u, v, weight in edges:
        if dist[u] + weight < dist[v]:
            print(f"检测到负权环：从{u}到{v}可以进一步优化")
            return None, None  # 返回None表示存在负环
    
    return dist, pred


def reconstruct_path(pred, s, t):
    """
    重构从s到t的最短路径
    
    参数:
        pred: 前驱节点字典
        s: 源顶点
        t: 目标顶点
    
    返回:
        str: 路径字符串
    """
    if pred is None or t not in pred:
        return "无法重构路径（可能检测到负环）"
    
    if pred[t] is None and t != s:
        return f"从{s}到{t}不存在路径"
    
    path = []
    current = t
    # 从目标回溯到源点
    while current is not None:
        path.append(current)
        if current == s:
            break
        current = pred.get(current)
    
    # 如果无法回溯到源点，说明没有路径
    if path[-1] != s:
        return f"从{s}到{t}没有完整路径"
    
    return " -> ".join(reversed(path))


# 测试图（有向带权图）
G = {
    "s": {"t": 8, "y": 5},
    "t": {"x": 1, "y": 2},
    "x": {"z": 4},
    "y": {"t": 3, "x": 9, "z": 2},
    "z": {"x": 6}
}

# 执行Bellman-Ford算法，源点为"s"
distances, predecessors = Bellman_Ford(G, s="s")

# 打印结果
if distances is not None:
    print("从源点's'出发的最短距离:")
    for vertex in sorted(G.keys()):
        print(f"  到 {vertex}: 距离 = {distances[vertex]}")
    
    print("\n前驱节点（用于重构路径）:")
    for vertex in sorted(G.keys()):
        if predecessors[vertex] is not None:
            print(f"  {vertex} <- {predecessors[vertex]}")
        else:
            print(f"  {vertex} <- None (源点)")
    
    # 示例：重构从s到z的路径
    print(f"\n从s到z的最短路径: {reconstruct_path(predecessors, 's', 'z')}")
else:
    print("算法检测到图中存在负权环")
```


## 所有点对最短路径问题
- 问题定义
    - 输入：带权图 $G=<V,E,W>$, $W$是边全
    - 输出： $\forall u,v \in V$,从 $u$ 到 $v$ 的最佳路径
- 算法设计
    - 动态规划
        - 问题结构分析
            - i到j的最短路等于i到k的最短路，k到j的最短路
        - 递推关系建立
            - 不选第k个点
                - $D[k,i,j] = D[k-1,i,j]$
            - 选择第k个点
                - $D[k,i,j] = D[k-1,i,k]+D[k-1,k,j]$
        - 自底向上计算
            - 初始化
                - $D[0,i,i]=0$,起始点重合，路径长度为0
                - $D[0,i,j]=e[i,j]$,任意两点直达距离为边权
            - 递推公式
                - $D[k,i,j]=\min{D[k-1,i,j],D[k-1,i,k]+D[k-1,k,j]}$
- 伪代码

<div align="center">
<img src="./Floyd-Warshall.svg" width="600" alt="DFS" />
</div>

```python
# Floyd_Warshall
import numpy as np
from collections import defaultdict

def Floyd_Warshall(G):
    """
    Floyd-Warshall算法：计算所有顶点对之间的最短路径
    
    参数:
        G: 带权有向图的邻接表表示，格式为 {顶点: {邻居: 权重}}
    
    返回:
        tuple: (D, Rec, index_to_vertex)
               D: 最短距离矩阵
               Rec: 路径重构矩阵
               index_to_vertex: 索引到顶点的映射
    """
    # 获取所有顶点并排序
    vertices = sorted(set(G.keys()) | {v for neighbors in G.values() for v in neighbors})
    n = len(vertices)
    
    # 创建顶点索引映射：顶点 -> 索引
    vertex_to_index = {v: i for i, v in enumerate(vertices)}
    index_to_vertex = {i: v for i, v in enumerate(vertices)}
    
    # 初始化距离矩阵D和路径重构矩阵Rec
    D = np.full((n, n), np.inf)  # 初始化为无穷大
    Rec = np.zeros((n, n), dtype=int)  # 记录中间顶点
    
    # 初始化：设置直接边的距离
    for i, u in enumerate(vertices):
        D[i][i] = 0  # 顶点到自身距离为0
        for v, weight in G.get(u, {}).items():
            j = vertex_to_index[v]
            D[i][j] = weight
    
    # Floyd-Warshall核心算法
    # k为中间顶点
    for k in range(n):
        for i in range(n):
            for j in range(n):
                # 如果通过k的路径更短，则更新
                if D[i][k] + D[k][j] < D[i][j]:
                    D[i][j] = D[i][k] + D[k][j]
                    Rec[i][j] = k + 1  # 记录中间顶点（1-indexed便于阅读）
    
    # 检查负环：如果对角线有负值，说明存在负权环
    for i in range(n):
        if D[i][i] < 0:
            print(f"警告：图中存在负权环，顶点{index_to_vertex[i]}在一个负环中")
    
    return D, Rec, index_to_vertex


def Find_Path(Rec, index_to_vertex, u_idx, v_idx):
    """
    递归查找并打印从u到v的路径
    
    参数:
        Rec: 路径重构矩阵
        index_to_vertex: 索引到顶点的映射
        u_idx: 起点索引
        v_idx: 终点索引
    """
    # 如果存在中间顶点k
    if Rec[u_idx][v_idx] != 0:
        k_idx = Rec[u_idx][v_idx] - 1  # 转回0-indexed
        # 递归打印u到k的路径
        Find_Path(Rec, index_to_vertex, u_idx, k_idx)
        # 打印k到v的路径
        Find_Path(Rec, index_to_vertex, k_idx, v_idx)
    else:
        # 没有中间顶点，直接打印终点
        v = index_to_vertex[v_idx]
        print(f" -> {v}", end="")


def print_shortest_paths(G):
    """
    计算并打印所有顶点对之间的最短路径和距离
    """
    D, Rec, idx_to_v = Floyd_Warshall(G)
    vertices = sorted(set(G.keys()) | {v for neighbors in G.values() for v in neighbors})
    n = len(vertices)
    
    print("=" * 60)
    print("所有顶点对之间的最短距离矩阵:")
    print("=" * 60)
    
    # 打印表头
    print(f"{'':4}", end="")
    for v in vertices:
        print(f"{v:>6}", end="")
    print()
    
    # 打印距离矩阵
    for i, u in enumerate(vertices):
        print(f"{u:>4}", end="")
        for j, v in enumerate(vertices):
            if D[i][j] == np.inf:
                print(f"{'∞':>6}", end="")
            else:
                print(f"{D[i][j]:>6.1f}", end="")
        print()
    
    print("\n" + "=" * 60)
    print("路径重构示例:")
    print("=" * 60)
    
    # 示例：打印从第一个顶点到第四个顶点的路径
    if n >= 4:
        start = vertices[0]
        end = vertices[3]
        
        print(f"\n从{start}到{end}的最短路径:")
        print(f"{start}", end="")
        Find_Path(Rec, idx_to_v, 0, 3)
        print(f"\n总距离: {D[0][3]:.1f}")
    
    # 打印从源点到所有其他点的路径
    print(f"\n从{vertices[0]}到所有其他顶点的路径:")
    for j, v in enumerate(vertices[1:], 1):
        print(f"\n到 {v}:", end="")
        print(f" {vertices[0]}", end="")
        Find_Path(Rec, idx_to_v, 0, j)
        print(f" (距离: {D[0][j]:.1f})")


# 测试图（带权有向图）
G = {
    1: {2: 200, 3: 100, 4: 500, 5: 500},
    2: {1: 200, 3: 200, 4: 1200, 5: 1000},
    3: {1: 100, 2: 200, 4: 200, 5: 600},
    4: {1: 500, 2: 1200, 3: 200, 5: 100},
    5: {1: 500, 2: 1000, 3: 600, 4: 100},
}

# 计算并打印所有最短路径
print_shortest_paths(G)
```






## 最大二分匹配
- 相关概念
    - 二分图
        - 给定一个无向图$G=<V,E>$，其中$V=L\cup R$,$L\cap R=\phi$，并且每条边$e\in E$，有一个端点在$L$中，有一个端点在 $R$中，其可记为二分图$G=<L,R,E>$
    - 匹配
        - 图$G=<V,E>$中的一个匹配 $M$是图 $G$边集 $E$的子集 ($M\subseteq E$),其中每个顶点至多关联 $M$的一条边
- 问题定义
    - 输入
        - 二分图$G=<L,R,E>$
    - 输出
        - 求出匹配 $M=\{e_1,e_2,..,e_k\}$,令
$$
\max{|M|}\\
s.t. \forall i,j(i\neq j),e_i =(l_i,r_i),e_j=(l_j,r_j),l_i\neq l_j,r_i\neq r_j
$$

- 相关概念
    - 交替路径
        - 从未匹配的顶点出发，依次经过 "非匹配的边，匹配边，非匹配边"形成的路径
- 匈牙利算法
    - 核心思想：不断寻找交替路径进行增广
    - 辅助数组
        - matched表示 $L$与 $R$中的顶点的匹配关系，以$R$中的顶点作为下标，$matched[R_2]\leftarrow L_1$
        - color表示深度优先搜索辅助数组。white表示未搜索过，black表示已被搜索过

<div align="center">
<img src="./hungarian.svg" width="600" alt="DFS" />
</div>

```python

def Hungarian(G):
    """
    匈牙利算法：求二分图的最大匹配
    
    参数:
        G: 二分图的邻接表表示，格式为 {左部顶点: {右部顶点集合}}
           例如: {"L1": {"R2"}, "L2": {"R1", "R3"}}
    
    返回:
        dict: 右部顶点到左部顶点的匹配字典
              格式: {右部顶点: 匹配的左部顶点}
    """
    # 获取所有左部顶点和右部顶点
    L = list(G.keys())  # 左部顶点列表
    R_set = set()        # 右部顶点集合
    for neighbors in G.values():
        R_set.update(neighbors)
    R = list(R_set)      # 右部顶点列表
    
    # matched: 记录右部顶点匹配的左部顶点
    # matched[r] = l 表示右部顶点r当前匹配左部顶点l
    matched = {r: None for r in R}
    
    # 对每个左部顶点尝试寻找增广路径
    for v in L:
        # color: 记录右部顶点在本次DFS中的访问状态
        color = {r: "white" for r in R}
        
        # 如果找到增广路径，则匹配成功
        if DFS_Find(G, v, color, matched):
            # 匹配成功，继续处理下一个左部顶点
            pass
    
    # 过滤掉未匹配的右部顶点
    return {r: l for r, l in matched.items() if l is not None}


def DFS_Find(G, v, color, matched):
    """
    DFS寻找增广路径
    
    参数:
        G: 二分图
        v: 当前访问的左部顶点
        color: 右部顶点的访问状态字典
        matched: 匹配字典，记录右部顶点匹配了哪个左部顶点
    
    返回:
        bool: 是否找到增广路径
    """
    # 遍历左部顶点v的所有右部邻居u
    for u in G.get(v, set()):
        # 如果右部顶点u已访问过，跳过（避免环路）
        if color[u] == "black":
            continue
        
        # 标记右部顶点u为已访问
        color[u] = "black"
        
        # 如果u是空闲的（未匹配），或者可以让给matched[u]（当前匹配u的左部顶点）
        # 并且matched[u]能找到其他匹配
        if matched[u] is None or DFS_Find(G, matched[u], color, matched):
            # 将u匹配给v
            matched[u] = v
            return True
    
    # 所有邻居都无法匹配，返回False
    return False


# ==================== 测试示例 ====================

# 二分图 G = <L, R, E>
# L: 左部顶点（工人）
# R: 右部顶点（任务）
G = {
    "L1": {"R2"},           # L1可以完成R2
    "L2": {"R1", "R3", "R5"},  # L2可以完成R1,R3,R5
    "L3": {"R1", "R4"},        # L3可以完成R1,R4
    "L4": {"R3"},              # L4可以完成R3
    "L5": {"R4"},              # L5可以完成R4
}

print("二分图结构:")
for left, rights in G.items():
    print(f"  {left} -> {rights}")

# 执行匈牙利算法
matching = Hungarian(G)

print("\n最大匹配结果:")
print("左部顶点 -> 右部顶点")
for right, left in matching.items():
    print(f"  {left} -> {right}")

print(f"\n最大匹配数: {len(matching)}")

# 验证最大匹配
expected_matching = 4  # 理论上最多4条匹配边
print(f"预期最大匹配数: {expected_matching}")
print(f"结果正确: {len(matching) == expected_matching}")

# 可视化匹配关系
print("\n匹配可视化:")
for left in sorted(G.keys()):
    matched_right = None
    for right, matched_left in matching.items():
        if matched_left == left:
            matched_right = right
            break
    if matched_right:
        print(f"✓ {left} 匹配 {matched_right}")
    else:
        print(f"✗ {left} 未匹配")

print("\n未匹配的右部顶点:")
all_right = set()
for neighbors in G.values():
    all_right.update(neighbors)
matched_right = set(matching.keys())
unmatched_right = all_right - matched_right
if unmatched_right:
    for r in sorted(unmatched_right):
        print(f"  - {r}")
else:
    print("  所有右部顶点都已匹配")
```


## 最大流
- 流网络
    - 给定有向图 $G=<V,E,C>$， 被称为流网络    
        - 容量：对于每条边 $c(e)\geq 0$
        - 流量：对于每条边 $c(e)\geq f(e)\geq 0$
        - 剩余容量：对于每条边，剩余容量为 $c(e)- f(e)$
        - 总流量： $|f|=\sum_{e out of s}f(e=\sum_{e in to t}f(e))$
    - 流量的两条性质
        - 容量限制：对边 $e\in E$,有 $0\leq f(e)\leq c(e)$
        - 流量守恒：对顶点$v\in V-\{s,t\},\sum_{eintov}f(e)=\sum_{e out of v}f(e)$,进入某顶点 $v$ 流量和等于流入此顶点流量和

- 问题定义  
    - 输入
        - 有向图$G=<V,E,C>$，其中$c(e)\in C$表示边$e$的容量
        - 源点 $s$,汇点 $t$
    - 输出
        - 总流量$|f|$
$$
\max{|f|}=\max{\sum_{e out of s}f(e)}\\
s.t.0\leq f(e)\leq c(e),\sum_{e in to v}f(e)=\sum_{e out of v}f(e)
$$

- 残存网络
    - 给定流网络 $G=<V,E,C>$和流量 $f$,可得残存网络 $G_f=<V,E_f>$，每条边的残存容量
    -   $$
        c_f(e)=\left \{
        \begin{aligned}
        c(e)-f(e),e为正向边\\
        f(e),e为反向边
        \end{aligned}\right.
        $$
    - 给定流网络 $G=<V,E>$和流 $f$,增广路径 $p$是残存网络$G_f$中一条冲源顶点$s$到汇点$t$的简单路径（路径上的各顶点均不互相重复）
    - 增广路径上的残存容量
        - 一条增广路径 $p$ 上各边残存容量的最小值
        -   $$
            c_f(p)=\min{\{c_f(e)|e\in p\}}
            $$

- 算法思想
    - 对所有边 $e\in E$,初始化流量为0，$f(e)=0$
    - 构造残存网络 $G_f$，寻找 $s$ 到 $t$的增广路径 $P$
    - 按路径 $P$的残存容量增加流量
    - 迭代寻找路径 $P$直至无法增加路径流量

- 伪代码

<div align="center">
<img src="./Ford-Fulkerson.svg" width="600" alt="DFS" />
</div>

```python
from collections import defaultdict, deque

def Ford_Fulkerson(G, s, t):
    """
    Ford-Fulkerson算法实现（使用BFS寻找增广路径，即Edmonds-Karp算法）
    
    参数:
        G: 网络的邻接表表示，格式为 {起点: {终点: 容量}}
           例如: {"s": {"v1": 12, "v2": 13}, "v1": {"v3": 10}}
        s: 源点（字符串）
        t: 汇点（字符串）
    
    返回:
        tuple: (max_flow, flow_dict)
               max_flow: 最大流值
               flow_dict: 字典，键为(起点, 终点)，值为当前流量
    """
    # 获取所有顶点
    vertices = set(G.keys())
    for neighbors in G.values():
        vertices.update(neighbors.keys())
    
    # 初始化流量字典：每条边的流量初始为0
    # flow[(u, v)] 表示边u->v的当前流量
    flow = defaultdict(int)
    
    # 主循环：不断寻找增广路径
    while True:
        # 使用BFS寻找从s到t的增广路径
        # parent字典记录路径：parent[v] = (u, residual_capacity)
        parent = {}
        queue = deque([s])
        visited = set([s])
        
        # BFS遍历残差图
        while queue:
            u = queue.popleft()
            
            # 遍历u的所有邻居v
            for v in G.get(u, {}):
                # 计算残差容量 = 容量 - 当前流量
                residual_capacity = G[u][v] - flow[(u, v)]
                
                # 如果残差容量>0且v未被访问
                if residual_capacity > 0 and v not in visited:
                    visited.add(v)
                    parent[v] = (u, residual_capacity)  # 记录前驱和残差容量
                    queue.append(v)
                    
                    if v == t:  # 提前到达汇点，找到增广路径
                        break
            
            # 如果已经找到汇点，退出BFS
            if t in visited:
                break
        
        # **终止条件**：如果汇点t未被访问，说明不存在增广路径
        if t not in visited:
            break
        
        # **计算瓶颈容量**：从t回溯到s，找到路径上的最小残差容量
        path_capacity = float('inf')
        current = t
        while current != s:
            u, cap = parent[current]
            path_capacity = min(path_capacity, cap)
            current = u
        
        # **增广流量**：沿找到的路径增加流量
        current = t
        while current != s:
            u, _ = parent[current]
            flow[(u, current)] += path_capacity  # 正向边增加流量
            # 反向边流量减少（残差网络中，反向边容量=原流量）
            flow[(current, u)] -= path_capacity
            current = u
        
        # 继续下一轮寻找增广路径
    
    # **计算最大流值**：从源点s出发的所有边的流量之和
    max_flow = sum(flow[(s, v)] for v in G.get(s, {}))
    
    return max_flow, flow


def print_network(G, flow_dict=None):
    """
    可视化网络状态
    
    参数:
        G: 网络结构
        flow_dict: 流量字典（可选）
    """
    print("=" * 60)
    print("网络结构")
    print("=" * 60)
    
    if flow_dict:
        print(f"{'边':<10} {'容量':<8} {'流量':<8} {'残差':<8}")
        print("-" * 35)
        for u, neighbors in G.items():
            for v, cap in neighbors.items():
                flow = flow_dict.get((u, v), 0)
                residual = cap - flow
                print(f"{u} -> {v:<4} {cap:<8} {flow:<8} {residual:<8}")
    else:
        print(f"{'边':<10} {'容量':<8}")
        print("-" * 20)
        for u, neighbors in G.items():
            for v, cap in neighbors.items():
                print(f"{u} -> {v:<4} {cap:<8}")


# ==================== 示例：构建网络 G=<V,E,C> ====================

# 网络V：顶点集合
# 网络E：边集合
# 网络C：容量函数

# 示例网络（教材经典例子）
G = {
    "s": {"v1": 12, "v2": 14},  # 源点到v1容量12，到v2容量14
    "v1": {"v3": 10},            # v1到v3容量10
    "v2": {"v1": 5, "v3": 11, "v4": 6},
    "v3": {"v4": 5, "t": 14},
    "v4": {"t": 11},
    "t": {}                      # 汇点没有出边
}

# 打印初始网络
print_network(G)

# 执行最大流算法
max_flow, flow_dict = Ford_Fulkerson(G, "s", "t")

print("\n" + "=" * 60)
print("最大流计算结果")
print("=" * 60)
print(f"最大流值: {max_flow}")
print("\n最终流量分布:")
print_network(G, flow_dict)

# 验证最大流
print("\n" + "=" * 60)
print("流量守恒验证（除s和t）：")
print("=" * 60)
for vertex in G:
    if vertex not in ["s", "t"]:
        # 计算流入流量
        in_flow = sum(flow_dict.get((u, vertex), 0) 
                     for u in G if vertex in G.get(u, {}))
        # 计算流出流量
        out_flow = sum(flow_dict.get((vertex, v), 0) 
                      for v in G.get(vertex, {}))
        print(f"{vertex}: 流入={in_flow}, 流出={out_flow}, 守恒={in_flow==out_flow}")

# 找到最小割
def min_cut(G, flow_dict, s):
    """
    根据最大流后的残差图，找到最小割
    
    参数:
        G: 原网络
        flow_dict: 最大流后的流量
        s: 源点
    
    返回:
        list: 源点所在割集的顶点
    """
    # BFS在残差图中寻找从s可达的顶点
    visited = set([s])
    queue = deque([s])
    
    while queue:
        u = queue.popleft()
        for v in G.get(u, {}):
            # 残差容量 > 0
            residual = G[u][v] - flow_dict.get((u, v), 0)
            if residual > 0 and v not in visited:
                visited.add(v)
                queue.append(v)
    
    return visited

source_side = min_cut(G, flow_dict, "s")
sink_side = set(G.keys()) - source_side

print("\n" + "=" * 60)
print("最小割（Max-Flow Min-Cut定理）：")
print("=" * 60)
print(f"源点侧S: {sorted(source_side)}")
print(f"汇点侧T: {sorted(sink_side)}")
print(f"割边（从S到T的边）：")
cut_edges = []
for u in source_side:
    for v in G.get(u, {}):
        if v in sink_side:
            capacity = G[u][v]
            flow = flow_dict.get((u, v), 0)
            cut_edges.append((u, v, capacity, flow))
            print(f"  {u} -> {v}: 容量={capacity}, 流量={flow}")
cut_capacity = sum(cap for _, _, cap, _ in cut_edges)
print(f"割的容量: {cut_capacity}")
print(f"最大流 = 最小割 = {cut_capacity}")
```