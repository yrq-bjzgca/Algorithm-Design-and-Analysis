# 贪心算法

## 经典例子1-部分背包问题

- 部分背包问题（Fractional Knapsack Problem）
    - 输入：
        -  $n$ 个物品组成的合集 $O$ ,每个物品有两个属性 $v_i$ 和 $p_i$ ,分别表示体积和价格
        - 背包的容量是 $C$
    - 输出：
        - 求解一个解决方案 $S=\{x_i|1\leq i\leq n,0\leq x_i\leq 1\}$
        - $$\max{\sum_{x_i\in S}}x_i\cdot p_i \quad \text{优化目标}$$
        $$s.t.\sum_{x_i\in S}x_i\cdot v_i\leq C \quad \text{约束条件}$$
- 策略
    - 选择性价比优先
        - 性价比=价格/体积
        - 优先选择高性价比的饮料全部装入，尽可能装满杯子
- 正确性证明
    - 贪心策略：最高性价比优先
    - 证明：贪心不劣于最优解
- 伪代码
<div align="center">
<img src="./fractionalKnapsack.svg" width="600" alt="贪心策略" />
</div> 

- 一般步骤
    - 提出贪心策略
        - 观察问题特征，构造贪心选择
    - 证明策略正确
        - 假设最优方案，通过替换证明

## 经典例子2-霍夫曼编码
- 霍夫曼编码
    - 问题背景：在计算机中常使用二进制串对不同字符进行编码
    - 编码树：顶点到左顶点的边标记为0，到右节点的边标记为1，通过编码方案构造编码树
    - 每条根到叶子的路径对应每个字符的二进制串

<div align="center">
<img src="./编码树.svg" width="600" alt="编码树" />
</div> 

- 最优前缀码
    - 输入：字符串 $n$ 以及各个字符的频数 $F=<f_1,f_2,...f_n>$

    - 输出：解析结果唯一的二进制编码方案 $C=<c_1,...c_n>$
    $$\min{\sum_{i=1}^{n}|c_i|f_i}\quad \text{优化目标}$$
    $$|c_i|为字符i 的编码二进制串的长度$$
- 贪心策略1
    - 优先处理高频字符，依次编码高频字符
        - 将字符频数从大到小排序， $F=<f_1,f_2,...,f_n>(f_1\geq f_2\geq...\geq f_n)$
        - 依次编码高频字符
- 贪心策略2
    - 优先处理低频字符
        - 将字符频数从小到大进行排序， $F=<f_1,f_2,....f_n>(f_1\leq f_2\leq...\leq f_n)$
        - 选两个最小的频数 $f_1,f_2$ 进行合并 $f^{'}=f_1+f_2$
        - 在 $F^{'}=<f^{'},f_3,..f_n>$ 中重复选择进行合并
<div align="center">
<img src="./Huffman.svg" width="600" alt="Huffman" />
</div> 

```python
class MinHeap:
    """
    手写最小堆（优先队列）实现
    
    核心性质：
    1. 完全二叉树结构
    2. 父节点值 ≤ 子节点值（最小堆性质）
    3. 用数组存储，索引i的父节点为(i-1)//2，左子节点为2*i+1，右子节点为2*i+2
    """
    
    def __init__(self):
        """初始化空堆"""
        self.heap = []  # 用列表存储堆元素
    
    def push(self, item):
        """
        插入元素并维持堆性质
        
        步骤：
        1. 将新元素添加到列表末尾
        2. 执行上浮操作（heapify_up）调整到正确位置
        """
        self.heap.append(item)
        self._heapify_up(len(self.heap) - 1)
    
    def pop(self):
        """
        弹出最小元素并维持堆性质
        
        步骤：
        1. 将堆顶（最小）元素与末尾元素交换
        2. 弹出并保存原堆顶元素
        3. 对新的堆顶执行下沉操作（heapify_down）
        4. 返回原堆顶元素
        
        返回:
            堆中最小元素
        """
        if len(self.heap) == 0:
            raise IndexError("堆为空")
        
        if len(self.heap) == 1:
            return self.heap.pop()
        
        # 交换堆顶和末尾
        self.heap[0], self.heap[-1] = self.heap[-1], self.heap[0]
        # 弹出原堆顶
        min_item = self.heap.pop()
        # 对新的堆顶执行下沉
        self._heapify_down(0)
        
        return min_item
    
    def _heapify_up(self, idx):
        """
        上浮操作：将索引idx处的元素向上调整至满足堆性质
        
        原理：
        比较节点与其父节点，如果节点值更小则交换，直到根节点或不再满足交换条件
        """
        while idx > 0:
            parent_idx = (idx - 1) // 2  # 父节点索引
            # 如果当前节点比父节点小，交换
            if self.heap[idx] < self.heap[parent_idx]:
                self.heap[idx], self.heap[parent_idx] = self.heap[parent_idx], self.heap[idx]
                idx = parent_idx  # 继续向上检查
            else:
                break
    
    def _heapify_down(self, idx):
        """
        下沉操作：将索引idx处的元素向下调整至满足堆性质
        
        原理：
        比较节点与其左右子节点，如果子节点更小，与最小的子节点交换，直到叶子节点
        """
        n = len(self.heap)
        while True:
            left_idx = 2 * idx + 1  # 左子节点索引
            right_idx = 2 * idx + 2  # 右子节点索引
            smallest = idx  # 假设当前节点最小
            
            # 找到三者中最小的
            if left_idx < n and self.heap[left_idx] < self.heap[smallest]:
                smallest = left_idx
            if right_idx < n and self.heap[right_idx] < self.heap[smallest]:
                smallest = right_idx
            
            # 如果最小的是子节点，交换并继续下沉
            if smallest != idx:
                self.heap[idx], self.heap[smallest] = self.heap[smallest], self.heap[idx]
                idx = smallest  # 继续向下检查
            else:
                break
    
    def __len__(self):
        """返回堆中元素数量"""
        return len(self.heap)
    
    def __repr__(self):
        """字符串表示，便于调试"""
        return f"MinHeap({self.heap})"


class Node:
    """
    哈夫曼树节点类
    
    属性:
        _name: 字符名称（叶子节点存储字符，内部节点为None）
        _value: 节点权值（字符频率）
        _left: 左子节点
        _right: 右子节点
    """
    def __init__(self, name=None, value=None):
        self._name = name
        self._value = value
        self._left = None
        self._right = None
    
    def __lt__(self, other):
        """定义比较规则，用于堆的排序（按权值value比较）"""
        return self._value < other._value
    
    def __repr__(self):
        """字符串表示，便于调试"""
        if self._name:
            return f"Node('{self._name}', {self._value})"
        else:
            return f"Node(*, {self._value})"


def Build_Huffman_Tree(F, names):
    """
    使用自定义的最小堆构建哈夫曼树
    
    参数:
        F: 频率列表，F[i]表示第i个字符的频率
        names: 字符列表，names[i]表示第i个字符
    
    返回:
        root: 哈夫曼树的根节点
    """
    # 创建最小堆并加入所有叶子节点
    heap = MinHeap()
    for i in range(len(F)):
        heap.push(Node(names[i], F[i]))
    
    # 当堆中节点数大于1时，不断合并最小的两个节点
    while len(heap) > 1:
        # 弹出两个权值最小的节点
        left = heap.pop()
        right = heap.pop()
        
        # 创建父节点，权值为两者之和
        parent = Node(None, left._value + right._value)
        parent._left = left
        parent._right = right
        
        # 将新节点加入堆
        heap.push(parent)
    
    # 返回根节点
    return heap.pop()


def Generate_Codes(root, current_code="", code_dict=None):
    """
    递归遍历哈夫曼树，为每个字符生成编码
    
    参数:
        root: 当前遍历的节点
        current_code: 从根到当前节点的路径编码（左0右1）
        code_dict: 存储编码结果的字典
    
    返回:
        code_dict: {字符: 编码} 映射字典
    """
    if code_dict is None:
        code_dict = {}
    
    # 叶子节点：记录字符编码
    if root._name is not None:
        code_dict[root._name] = current_code if current_code != "" else "0"
        return code_dict
    
    # 递归遍历左子树，路径添加'0'
    if root._left:
        Generate_Codes(root._left, current_code + "0", code_dict)
    
    # 递归遍历右子树，路径添加'1'
    if root._right:
        Generate_Codes(root._right, current_code + "1", code_dict)
    
    return code_dict


def Print_Tree(node, level=0, prefix="Root"):
    """
    可视化打印哈夫曼树结构（辅助函数）
    
    参数:
        node: 当前节点
        level: 节点深度（用于缩进）
        prefix: 节点描述（Root/Left/Right）
    """
    if node is None:
        return
    
    # 打印当前节点
    indent = "  " * level
    if node._name:
        print(f"{indent}{prefix}: '{node._name}' (freq={node._value})")
    else:
        print(f"{indent}{prefix}: * (freq={node._value})")
    
    # 递归打印子树
    if node._left:
        Print_Tree(node._left, level + 1, "Left")
    if node._right:
        Print_Tree(node._right, level + 1, "Right")


def Huffman(F, names):
    """
    完整的哈夫曼编码流程
    
    参数:
        F: 频率列表
        names: 字符列表
    
    返回:
        code_dict: 编码字典
        root: 哈夫曼树根节点
    """
    # 步骤1: 构建哈夫曼树
    root = Build_Huffman_Tree(F, names)
    
    # 步骤2: 生成编码表
    code_dict = Generate_Codes(root)
    
    return code_dict, root


# ------------------------------------------------------------------
# 主程序测试与演示
# ------------------------------------------------------------------
if __name__ == "__main__":
    # 测试数据：6个字符及其频率
    F = [5, 9, 12, 13, 16, 45]      # 频率
    names = ['f', 'e', 'c', 'b', 'd', 'a']  # 对应字符
    
    print("="*60)
    print("哈夫曼编码演示（手写优先队列版本）")
    print("="*60)
    
    # 执行哈夫曼编码
    code_dict, root = Huffman(F, names)
    
    # 打印哈夫曼树结构
    print("\n哈夫曼树结构:")
    print("-"*30)
    Print_Tree(root)
    
    # 打印编码表
    print("\n" + "="*60)
    print("哈夫曼编码表（按频率降序）:")
    print("-"*30)
    sorted_items = sorted(code_dict.items(), key=lambda x: F[names.index(x[0])], reverse=True)
    for char, code in sorted_items:
        freq = F[names.index(char)]
        print(f"  '{char}': {code:>6s}  (频率: {freq:2d})")
    
    # 编码示例
    print("\n" + "="*60)
    test_string = "fecbda"
    encoded = Encode_String(test_string, code_dict)
    print(f"\n字符串 '{test_string}' 的哈夫曼编码:")
    print(f"  编码结果: {encoded}")
    print(f"  编码长度: {len(encoded)} 位")
    
    # 性能与复杂度分析
    print("\n" + "="*60)
    print("复杂度分析:")
    print("-"*30)
    print(f"  字符种类数: {len(F)}")
    print(f"  优先队列版本时间复杂度: O(n log n)")
    print(f"  手写堆操作时间复杂度: O(n log n)")
    print(f"  空间复杂度: O(n)")
    print("="*60)
    
    # 验证前缀性质
    codes = list(code_dict.values())
    prefix_free = True
    for i in range(len(codes)):
        for j in range(len(codes)):
            if i != j and codes[i].startswith(codes[j]):
                prefix_free = False
                break
    print(f"\n前缀性质验证: {'✓ 满足' if prefix_free else '✗ 不满足'}")
```

## 经典例子3-活动选择问题

- 活动选择问题
    - 问题背景
        - 会场出租：选择出租的活动时间不冲突
        - 输入：
            - $n$个活动组成的集合 $S=\{a_1,a_2,...a_n\}$
            - 每个活动 $a_i$的开始时间 $s_i$ 和结束时间 $f_i$ 
        - 输出：
            - 找出活动集合 $S$ 的子集 $S^{'}$ ,
            $$\max{|S^{'}|}$$
            $$s.t.\forall a_i,a_j\in S^{'},s_i\geq f_j 或者 s_j \geq f_i$$
- 贪心策略
    - 最短的活动优先
    - 最早开始的活动优先
    - 最早结束的活动优先：选择最早结束的活动，可以给后面的活动留更大的选择空间


<div align="center">
<img src="./会场选择.svg" width="600" alt="会场选择" />
</div> 

```python
class Activity:
    """
    活动类：包装区间和名称，便于排序和输出
    """
    def __init__(self, name, start, end):
        self.name = name
        self.start = start
        self.end = end
    
    def __repr__(self):
        return f"{self.name}: [{self.start}, {self.end}]"


def greedy_activity_selector(S):
    """
    活动选择问题贪心算法（不带权重）
    目标：选择最多数量的互不冲突活动
    
    参数:
        S: 字典，键为活动名，值为[开始时间, 结束时间]
    
    返回:
        selected_names: 被选中的活动名称列表
        selected_intervals: 被选中的活动区间列表
    """
    
    # ------------------------------------------------------------------
    # 阶段1: 从字典中提取所有活动并转换为对象列表
    # ------------------------------------------------------------------
    # 将字典转为Activity对象列表，保留名称信息以便后续输出
    activities = [Activity(name, interval[0], interval[1]) 
                  for name, interval in S.items()]
    
    # ------------------------------------------------------------------
    # 阶段2: 按结束时间排序（贪心策略核心）
    # ------------------------------------------------------------------
    # 为什么按结束时间排序？优先选择结束早的活动，给后续活动留出更多时间
    activities.sort(key=lambda act: act.end)
    
    # ------------------------------------------------------------------
    # 阶段3: 贪心选择过程
    # ------------------------------------------------------------------
    selected_names = []      # 存储选中的活动名称
    selected_intervals = []  # 存储选中的活动区间
    last_end_time = -1       # 上一个选中活动的结束时间（初始化为负无穷）
    
    # 遍历所有已排序的活动
    for act in activities:
        # 如果当前活动的开始时间 >= 上一个活动的结束时间
        # 说明这两个活动不冲突（兼容）
        if act.start >= last_end_time:
            selected_names.append(act.name)        # 记录活动名
            selected_intervals.append([act.start, act.end])  # 记录区间
            last_end_time = act.end               # 更新结束时间
    
    # ------------------------------------------------------------------
    # 阶段4: 返回结果
    # ------------------------------------------------------------------
    return selected_names, selected_intervals

"""
第二种写法
"""

# 不带权重的活动选择贪心算法
def greedy_activity_selector(S):
    """
    活动选择问题贪心算法
    目标：选择最多数量的互不重叠活动
    
    参数:
        S: 字典，键为活动名称，值为[开始时间, 结束时间]
    
    返回:
        selected_names: 选中的活动名称列表
        selected_intervals: 选中的活动区间列表
    """
    # 将字典转换为(名称, 开始, 结束)元组列表
    activities = [(name, interval[0], interval[1]) 
                  for name, interval in S.items()]
    
    # 按结束时间排序（贪心策略核心）
    activities.sort(key=lambda x: x[2])
    
    selected_names = []
    selected_intervals = []
    last_end_time = -1  # 上一个选中活动的结束时间
    
    # 遍历所有已排序的活动
    for name, start, end in activities:
        # 如果活动不冲突则选中
        if start >= last_end_time:
            selected_names.append(name)
            selected_intervals.append([start, end])
            last_end_time = end
    
    return selected_names, selected_intervals


# ------------------------------------------------------------------
# 测试数据
# ------------------------------------------------------------------
S = {
    'a1': [1, 4], 'a2': [3, 5], 'a3': [0, 6], 'a4': [4, 7],
    'a5': [3, 9], 'a6': [5, 9], 'a7': [6, 10], 'a8': [8, 11],
    'a9': [8, 12], 'a10': [2, 14], 'a11': [12, 16]
}

# ------------------------------------------------------------------
# 执行算法并打印结果
# ------------------------------------------------------------------
if __name__ == "__main__":
    names, intervals = greedy_activity_selector(S)
    
    print("="*60)
    print("活动选择问题（贪心算法）")
    print("="*60)
    print(f"总活动数: {len(S)}")
    print(f"可安排的最大活动数: {len(names)}")
    print("-"*60)
    print("选中的活动（按开始时间排序）:")
    
    # 按开始时间排序后输出，更直观
    sorted_results = sorted(zip(names, intervals), key=lambda x: x[1][0])
    for name, interval in sorted_results:
        print(f"  {name}: 开始时间={interval[0]}, 结束时间={interval[1]}")
    
    print("="*60)
```

- 带权的活动选择问题
    - 输入：
        - $n$个活动组成的集合 $S=\{a_1,a_2,...a_n\}$
        - 每个活动 $a_i$的开始时间 $s_i$ 和结束时间 $f_i$ 和权重 $w_i$
    - 输出：
        - 找出活动集合 $S$ 的子集 $S^{'}$ ,
        $$\max{\sum_{a_i\in S^{'}}w_i}\quad \text{优化目标：最大化权重之和}$$
        $$s.t.\forall a_i,a_j\in S^{'},s_i\geq f_j 或者 s_j \geq f_i\quad \text{约束条件}$$

- 算法步骤
    - 存在折叠子问题，使用动态规划进行求解
        - 预处理
            - 排序：按照活动结束的时间进行升序排序
            - 求 $p[i]$:在 $a_i$ 开始前最后结束的活动（排序之后使用二分查找）
        - 给出问题表示
            - $D[i]$:集合 $\{a_1,a_2,a_3,...a_i\}$ 中不冲突活动最大权重和
        - 明确原始问题
            - $D[n]$:集合 $\{a_1,a_2,a_3,...a_n\}$ 中不冲突活动最大权重和
    - 递推关系建立
        - 分析子结构
            - 考察活动 $a_i$:选择/不选择
            - 递推公式：
                - $D[i]=\max\{D[p[i]]+w_i,D[i-1]\}$
    - 自底向上计算
        - 初始化
            - $D[0]=0$,空活动集最大的权重和是0
        - 递推公式
            - $D[i]=\max{D[p[i]]+w_i,D[i-1]}$

<div align="center">
<img src="./带权的会场选择.svg" width="600" alt="带权的会场选择" />
</div> 

```python
class Activity:
    """
    活动类：封装活动信息
    
    属性:
        name: 活动名称
        start: 开始时间
        end: 结束时间
        weight: 活动权重/价值
    """
    def __init__(self, name, start, end, weight):
        self.name = name
        self.start = start
        self.end = end
        self.weight = weight
    
    def __repr__(self):
        """返回字符串表示，便于调试和打印"""
        return f"{self.name}: [{self.start}, {self.end}] (权重={self.weight})"


def Weighted_Activity_Selector(S, weights):
    """
    带权重的活动选择问题动态规划解法（二分查找优化版）
    
    参数:
        S: 字典，键为活动名，值为[开始时间, 结束时间]
        weights: 字典，键为活动名，值为权重
    
    返回:
        max_weight: 最大权重和
        selected_names: 被选中的活动名称列表
    """
    
    # ------------------------------------------------------------------
    # 阶段1: 将字典转换为Activity对象列表（添加哨兵活动）
    # ------------------------------------------------------------------
    # 创建Activity对象列表，在索引0处添加哨兵活动（简化边界条件）
    # 哨兵活动: start=-1, end=-1, weight=0，确保DP数组从1开始
    activities = [Activity("dummy", -1, -1, 0)]  # 索引0的哨兵
    
    # 遍历字典创建实际活动对象
    for name, interval in S.items():
        activities.append(Activity(name, interval[0], interval[1], weights[name]))
    
    # 按结束时间排序（保持哨兵在开头，即索引0）
    activities = [activities[0]] + sorted(activities[1:], key=lambda act: act.end)
    
    n = len(activities) - 1  # 排除哨兵后的实际活动数量
    
    # ------------------------------------------------------------------
    # 阶段2: 使用二分查找计算前驱数组p[i]（优化核心）
    # ------------------------------------------------------------------
    # p[i]表示在i之前最后一个与i兼容的活动索引（包含哨兵）
    p = [0] * (n + 1)  # p[0] = 0
    
    # 二分查找辅助函数：查找最后一个满足end <= target的索引
    def find_predecessor(target_start, end_idx):
        """
        在activities[0:end_idx]中二分查找最后一个结束时间≤target_start的索引
        
        参数:
            target_start: 当前活动的开始时间
            end_idx: 查找范围的上界（不包含）
        
        返回:
            满足条件的最大索引（若不存在返回0，即哨兵）
        """
        left, right = 0, end_idx - 1
        result = 0  # 默认返回哨兵索引0
        
        while left <= right:
            mid = (left + right) // 2
            if activities[mid].end <= target_start:
                result = mid  # 记录候选答案
                left = mid + 1  # 向右继续查找更晚结束的活动
            else:
                right = mid - 1  # 向左查找
        
        return result
    
    # 为每个活动计算前驱（i从1到n）
    for i in range(1, n + 1):
        p[i] = find_predecessor(activities[i].start, i)
    
    # ------------------------------------------------------------------
    # 阶段3: 动态规划（自底向上）
    # ------------------------------------------------------------------
    # DP[i]表示前i个活动（索引1到i）能获得的最大权重和
    DP = [0] * (n + 1)
    
    # chosen[i]记录第i个活动是否被选中
    chosen = [False] * (n + 1)
    
    for i in range(1, n + 1):
        # 情况1：不选择第i个活动
        not_choose = DP[i - 1]
        
        # 情况2：选择第i个活动
        # 收益 = 当前活动权重 + 前驱活动的DP值
        choose = activities[i].weight + DP[p[i]]
        
        # 选择收益更大的方案
        if choose > not_choose:
            DP[i] = choose
            chosen[i] = True
        else:
            DP[i] = not_choose
            chosen[i] = False
    
    # ------------------------------------------------------------------
    # 阶段4: 回溯找出选中的活动
    # ------------------------------------------------------------------
    selected_names = []
    idx = n
    
    # 从后往前回溯，根据chosen数组判断哪些活动被选中
    while idx > 0:
        if chosen[idx]:
            # 如果选择了第idx个活动
            selected_names.append(activities[idx].name)
            idx = p[idx]  # 跳转到其前驱活动
        else:
            idx -= 1  # 继续检查前一个活动
    
    # 恢复按开始时间排序的顺序
    selected_names.reverse()
    
    return DP[n], selected_names


# ------------------------------------------------------------------
# 测试数据（注意：weight中补充了a11）
# ------------------------------------------------------------------
S = {
    'a1': [1, 4], 'a2': [3, 5], 'a3': [0, 6], 'a4': [4, 7],
    'a5': [3, 9], 'a6': [5, 9], 'a7': [6, 10], 'a8': [8, 11],
    'a9': [8, 12], 'a10': [2, 14], 'a11': [12, 16]
}

weights = {
    'a1': 1, 'a2': 6, 'a3': 4, 'a4': 7, 'a5': 3, 'a6': 12, 
    'a7': 2, 'a8': 9, 'a9': 11, 'a10': 8, 'a11': 5
}

# ------------------------------------------------------------------
# 执行算法并打印结果
# ------------------------------------------------------------------
if __name__ == "__main__":
    max_weight, selected = Weighted_Activity_Selector(S, weights)
    
    print("="*60)
    print("带权重的活动选择问题（二分查找优化）")
    print("="*60)
    print(f"总活动数: {len(S)}")
    print(f"最大权重和: {max_weight}")
    print("-"*60)
    print("选中的活动方案:")
    
    # 按时间顺序显示
    total_weight = 0
    for name in selected:
        interval = S[name]
        weight_val = weights[name]
        total_weight += weight_val
        print(f"  {name}: 时间 [{interval[0]}, {interval[1]}], 权重={weight_val}")
    
```