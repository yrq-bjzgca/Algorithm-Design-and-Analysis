# 动态规划
## 一般步骤
- 问题结构分析
    - 给出问题表示，明确原始问题
- 递推关系建立
    - 分析最优结果，构造递推公式
- 自底向上计算
    - 确定计算顺序，依次求解问题
- 最优方案追踪
    - 记录决策过程，输出最优方案
## 经典问题
### 0-1背包问题

- 问题背景：超市允许顾客使用一个体积为13的背包，选择一件或者多件商品带走

| 商品 | 价格 | 体积 |
|---------|---------|---------|
| 啤酒   |  24  |  10  |
| 汽水   |  2   |  3   |
| 饼干   |  9   |  4   |
| 面包   |  10  |  5   |
| 牛奶   |  9   |  4   |

- 名称：0-1背包问题(0-1Knapsack Probelm)
- 输入： 
    - $n$ 个商品组成集合 $O$ ,每个商品都有两个属性 $v_i$ 和 $p_i$ ,分别表示体积和价格
    - 背包的容量为 $C$

- 输出：
    - 求解一个商品子集 $S\subseteq  O$  ，令 

$$
\begin{aligned}
\max \quad & \sum_{i\in S} p_i \quad \text{(优化目标)}\\
\text{s.t.} \quad & \sum_{i \in S} v_i \leq C \quad \text{(约束条件)}
\end{aligned}
$$

#### 策略
- 策略1：按照商品价格从低到高进行排序，优选挑选价格高的商品（非最优解）
- 策略2：按照商品体积从小到大排序，优先挑选体积小的商品（非最优解）
- 策略3：按照商品价值与体积的比由低到高进行排序，优先挑选比值高的商品（非最优解）
- 蛮力枚举
    - 思路：任意选一件商品，之后遍历选第二件...,，同时检查体积约束
    - 一共有 $2^n-1$ 种情况，检查体积约束

<div align="center">
<img src="./knapsackSR.svg" width="600" alt="knapsackSR" />
</div>

*存在的问题：重复求解大量子问题*

<div align="center">
<img src="./knapsack_problem.svg" width="600" alt="knapsack_problem" />
</div>

- 带有备忘录的递归
    - 在递归结果里加入一个备忘录 $P[i,c]\leftarrow P$
    - 在递归之前判断是不是计算过 $if P[i,c] \neq NULL$

<div align="center">
<img src="./knapsackMR.svg" width="600" alt="knapsackMR" />
</div>

- 动态规划：自底向上
*递推公式*
$$
P[i,c]=\max{\{P[i-1,c-v[i]]+p[i],P[i-1,c]\}}
$$
- 公式解释
    -  $P[i-1,c]$ 表示不选择商品 $i$ 
    -  $P[i-1,c-v[i]]+p[i]$ 表示选择商品 $i$ 

*记录递推过程*
$$
Rec[i,c]=\begin{cases}
1,\text{选择商品}\\
0,\text{不选择商品}
\end{cases}
$$

倒序判断是否选择商品

根据选择结果，确定最优子问题

#### 伪代码

<div align="center">
<img src="./knapsackDP.svg" width="600" alt="knapsackDP" />
</div>

#### 动态规划一般步骤
-问题结构分析
    - 给出问题表示
        -  $P[i,c]$ :前 $i$ 个商品可选、背包容量为 $c$ 时的最大总价格
    - 明确原始问题
        -  $P[n,C]$ :前 $n$ 个商品可选，背包容量为 $C$ 时的最大总价格
- 递推关系建立
    - 分析最优子结构
        - 问题的最优解由相关子问题最优解**组合构成** ，子问题可以**独立求解**
    - 构造递推式
        - $P[i,c]=\max{\{P[i-1,c-v[i]]+p[i],P[i-1,c]\}}$
- 自底向上计算
    - 确定计算顺序
        - 初始化
            - 容量为0的时候： $P[i,0]=0$ 没有商品的时候 $P[0,c]=0$
        -  $P[i,c]$ 依赖于子问题 $P[i-1,c-v_i]$ 和 $P[i-1,c]$ 
    - 依次求解问题

- 最优方案追踪
    - 记录决策过程
        -   $
            Rec[i,c]=\begin{cases}
            1,\text{选择商品}\\
            0,\text{不选择商品}
            \end{cases}
            $
    - 输出最优方案
        - 倒序判断是否选择商品
        -  $Rec[i,c]=1$时，选择商品 $i$ ,考察子问题 $P[i-1,c-v_i]$
        -  $Rec[i,c]=0$时，不选商品 $i$ ,考察子问题 $P[i-1,c]$

### 最大子数组问题II

- 问题：寻找数组  $X$ 最大的非空子数组,（Max continuous Subarray,MCS）
    - 输入：
        - 给定一个数组 $X[1..n]$ ,对于任意一对数组下标为 $l,r(l\leq r)$ 的非空数组，其和记为 $S[l,r]=\sum_{i=l}^{r}X[i]$
    - 输出：
        - 求出 $S(l,r)$ 的最大值， 记为 $S_{max}$
#### 策略
- 蛮力枚举
    - 数组 $X[1,n]$ ,其所有的下标 $l,r(l \leq r)$ 组合分为以下俩种情况
        - 当 $l=r$ 时， 一共有 $C_{n}^{1}$ 种组合
        - 当 $l<r$ 时， 一共有 $C_{n}^{2}$ 种组合
    - 枚举 $C_{n}^{1} + C_{n}^{2}$ 种下标 $l,r$ 组合，求出最大子数组之和
- 优化枚举

- 分而治之

- 动态规划
    - 问题结构分析：
        -  $D_i$:以 $X[i]$ 为开头的最大子数组和
    - 明确原始问题：
        -  $S_{max}=\max_{1\leq i\leq n}{\{D[i]\}}$
    - 递推关系建立:分析最优子结构
        - $D_i$:以 $X[i]$ 开头的最大子数组和
        - 情况1： $D_{i+1}>0$  , $D[i]=D[i+1]+X[i]$
        - 情况2： $D_{i+1}\leq 0$  $D[i]=X[i]$
    - 递推关系建立:构造递推公式
        -   $$
            D[i]=\begin{cases}
            X[i]+D[i+1] , &  \text{if}\quad D[i+1]>0\\
            X[i] , &  \text{if}\quad D[i+1]\leq 0
            \end{cases}
            $$
    - 自底向上计算：确定计算顺序
        - 初始化：
            - $D[n]=X[n]$
        - 递推公式：
            -   $$
                D[i]=\begin{cases}
                X[i]+D[i+1] , &  \text{if}\quad D[i+1]>0\\
                X[i] , &  \text{if}\quad D[i+1]\leq 0
                \end{cases}
                $$
    - 最优方案追踪：记录决策过程
        - 构造追踪数组 $Rec[1..n]$ 
            - 情况1：结尾相同
                - $Rec[i]=Rec[i+1]$
            - 情况2：结尾不同
                - $Rec[i]=i$ 
        - 从子问题种查找最优解
            - 最大子数组开头位置: $i$ 
            - 最大子数组结尾位置: $Rec[i]$ 

- 伪代码
<div align="center">
<img src="./mcs-5.svg" width="600" alt="动态规划MCS" />
</div>

### 最长公共子序列

- 子序列：给定序列中零个或多个元素(如字符)去掉之后得到的结果
- 形式化定义：
    - 输入：
        - 序列 $X=<x_1,x_2,...,x_n>$ 和序列 $Y=<y_1,y_2,...,y_m>$ 
    - 输出：
        - 求解一个公共子序列 $Z=<z_1,z_2,...,z_l>$
        $$\max|z|$$
        $$s.t.<z_1,z_2,...z_l>=<x_{i1},x_{i2},...,x_{il}>=<y_{j1},y_{j2},...,y_{jl}>$$
        $$1\leq i_1\leq i_2,....i_l\leq n;1\leq j_1\leq j_2,...\leq j_l\leq m$$
#### 策略
- 动态规划
    - 问题结构分析
        - 给出问题表示：
            -  $C[i,j]$ : $X[1...i]$ 和 $Y[1,...j]$ 的最长公共子序列长度
        - 明确原始问题：
            -  $C[n,m]$ : $X[1,..n]$ 和 $Y[1..m]$ 的最长公共子序列长度
    - 分析最优子结构
        - 考察末尾字符
            -  当 $x_i \neq y_j$ , $C[i,j]=\max{\{C[i-1,j],C[i,j-1]\}}$
            -  当 $x_i = y_j$ , $C[i,j]=C[i-1,j-1]+1$
        - 递推关系式建立
            -   $$
                C[i,j]=\begin{cases}
                \max{\{C[i-1,j],C[i,j-1]\}},& x_i \neq y_j\\
                C[i-1,j-1]+1,& x_i=y_j
                \end{cases}
                $$
        - 自底向上计算
            - 初始化
                - $C[i,0]=C[0,j]=0$， 某序列长度为0的时候，最长公共子序列长度为0 
            - 递推公式
                - $$C[i,j]=\begin{cases}
                    \max{\{C[i-1,j],C[i,j-1]\}},& x_i \neq y_j\\
                    C[i-1,j-1]+1,& x_i=y_j
                    \end{cases}
                    $$
            - 构造追踪数组 $rec[1..n]$ ,记录子问题的来源
                -   $$
                    rec[i,j]=\begin{cases}
                    LU,& \text{if} C[i,j]=C[i-1,j-1]+1\\
                    U,&\text{if}C[i,j]=C[i-1,j]\\
                    L,&\text{if}C[i,j]=C[i,j-1]
                    \end{cases}
                    $$
                - 最长公共子序列在 $X[1,...,i-1]$ 和 $Y[1,..j]$中
                - 最长公共子序列末尾是 $X[i]=Y[j]$
- 伪代码
<div align="center">
<img src="./LCS.svg" width="600" alt="LCS" />
</div>

### 最长公共子串问题
- 基本概念：
    - 子序列：将给定的序列中的0个或者多个元素(如字符)去掉之后的得到的结果
    - 子串：给定序列中0个或者多个连续的元素(如字符)组成的子序列

- 形式化定义：
    - 输入：
        - 序列 $X=<x_1,x_2,...,x_n>$ 和序列 $Y=<y_1,y_2,...,y_m>$ 
    - 输出：
        - 求解一个公共子串 $Z=<z_1,z_2,...,z_l>$
        $$\max|z|$$
        $$s.t.<z_1,z_2,...z_l>=<x_{i},x_{i+1},...,x_{i+l-1}>=<y_{j},y_{j1},...,y_{j+l-1}>$$
        $$1\leq i \leq n-l+1;1\leq j\leq m-l+1$$

#### 策略
- 蛮力枚举
    - 序列$X$和序列$Y$各选择一个位置
    - 依次检查元素是否匹配
        -元素相等则继续匹配
- 动态规划
    - 问题结构分析
        - $C[i,j]$
            -  $X[1,..,i]$ 和 $Y[1,...,j]$ 中,以 $x_i$ 和 $y_i$ 结尾的最长公共子串 $Z[1,...,l]$ 的长度
        - 明确原始问题
            -  $P_{max}=\max_{1\leq i\leq n,1\leq j\leq m}{\{C[i,j]\}}$
            - $X[1,..,n]$ 和 $Y[1..m]$ 中最长公共子串的长度
    - 递推关系建立
        - 分析最优子结构
        - 构造递推公式
        $$
        C[i,j]=\begin{cases}
        0&x_i\neq y_j\\
        C[i-1,j-1]+1&x_i=y_j
        \end{cases}
        $$
    - 自底向上计算：确定计算顺序
        - 初始化
            - $C[i,0]=C[0,j]=0$
            - 某序列长度为0的时候，最长公共子串为0
        - 递推公式
        $$
        C[i,j]=\begin{cases}
        0&x_i\neq y_j\\
        C[i-1,j-1]+1&x_i=y_j
        \end{cases}
        $$
        - 原始问题
            - $p_{max}=\max_{1\leq i \leq n,1\leq j\leq m}{\{C[i,j]\}}$
    - 最优方案追踪
        - 记录决策过程
            - 最长公共子串末尾位置为 $p_{max}$
            - 最长公共子串长度为 $l_{max}$
    - 输出最优方案
        - 最长公共子串 $<x_{p_{max}-l+1},...x_{p_{max}}>$
- 伪代码
<div align="center">
<img src="./LCS-1.svg" width="600" alt="公共子串" />
</div>

### 编辑距离问题
- 问题背景：输入法自动更正
- 基本思想：字符串A -编辑操作-> 字符串B
- 基本操作：删除、插入、替换
- 形式化定义：
    - 问题名称：Minimum Edit Distance,MED
    - 输入：长度为 $n$ 的字符串 $s$, 长度为 $m$ 的字符串 $t$
    - 输出：求出一组编辑操作 $O=<e_1,e_2,...e_d>$,令
    $$\min{|O|}$$
    $$s.t.字符串s经过O操作之后满足s=t$$
- 问题结构分析:
    - 给出问题表示
        - $D[i,j]$: 字符串$s[1..i]$变为$t[1..j]$的最小编辑距离
    - 明确原始问题：
        - $D[n,m]$:字符串$s[1..n]$变为$t[1..m]$的最小编辑距离
-  递推关系建立：
    - 最长公共子序列
        - 如果 $s_i \neq t_j$
        - 如果 $s_i=t_j$
    - 考察末尾元素：删除、插入、替换
        - 删除：$$ D[i,j]=D[i-1,j]+1$$
        - 插入：$$ D[i,j]=D[i,j-1]+1$$
        - 替换: $$ D[i,j]=D[i-1,j-1]+\begin{cases}
        0,& \text{if} \quad s[i] = t[j]\\
        1,& \text{if} \quad s[i]\neq t[j]\\
        \end{cases}$$
    - 构造递推公式
    $$D[i,j]=\begin{cases}
    D[i-1,j]+1 &删除\\
    D[i,j-1]+1 &插入\\
    D[i-1,j-1]+\begin{cases}
    0,& \text{if} \quad s[i] = t[j] \\
    1,& \text{if} \quad s[i]\neq t[j]
    \end{cases}
    \end{cases}$$
    - 初始化
        - $D[i,0]=i$
            - 把长度为 $i$ 的串变成空串需要 $i$ 次操作（删除）
        - $D[0,j]=j$
            - 把长度为 $j$ 的空串变成串需要 $j$ 次操作（插入）
    - 记录决策过程
        - 追踪数组，输出最小编辑操作

- 伪代码
<div align="center">
<img src="./MED.svg" width="600" alt="编辑距离" />
</div>        

### 钢条切割问题
- 问题背景：现在有一个长度是10的钢条，可以零成本将其切割为多段长度更小的钢条，不同长度的钢条价格不一样，怎么切割可以使得总收益最大
- 形式化定义：
    - 输入：
        - 钢条长度
        - 价格表 $p_i(1\leq l \leq n)$:表示长度为 $l$ 的钢条价格
    - 输出：
        - 求解一组切割方案 $T=<c_1,c_2,...c_m>$ ,令
        $$\max{\sum_{l=1}^{m}}{p_{c_l}}\quad\text{优化目标}$$
        $$s.t.\sum{l=1}^{m}c_l = n\quad\text{约束条件}$$

- 问题简述
    - 假设至多切割一次
        - 枚举所有的可能切割位置:
            - 不切: $p[10]$
            - 切割: $p[i]+p[10-i]$
        - 最大收益:
            - $max_{1\leq i \leq 9}\{p[i]+p[10-i],p[10]\}$


- 问题结构分析
    - 给出问题表示：
        - $c[j]$:切割长度为 $j$ 的钢条可以获得最大的总收益
    - 明确原始问题：
        - $C[n]$:切割长度为 $n$ 的钢条可以获得最大的总收益
- 递推关系建立
    - 分析最优子结构：
        - 对每个钢条长度 $j$：
        - $$C[j]=\max_{1\leq i\leq j-1}\{p[i]+C[j-i],p[j]\}$$

- 自底向上计算：
    - 依次求解问题
        - 初始化
            - $C[0]=0$,切割长度为0的钢条，总收益为0
        - 递推公式
            - $$C[j]=\max_{1\leq i\leq j-1}\{p[i]+C[j-i],p[j]\}$$
- 最优方案追踪：记录决策过程
    - 构造追踪数组 $rec[1..n]$
    - $rec[j]$:记录长度为 $j$ 钢条的最优切割方案

- 伪代码
<div align="center">
<img src="./RodCutting.svg" width="600" alt="钢条切割" />
</div> 

### 矩阵链乘法问题

- 问题背景：
    - 基本知识：两个矩阵相乘，矩阵大小是 $p\times q,q\times r$
    - 矩阵乘法的时间复杂度：
        - 计算1个数字：需要 $q$ 次标量乘法
        - 共计 $p\times r$ 个数， $\Theta(pqr)$
    - 三个矩阵相乘：
        - 矩阵乘法的结合律：$(UV)W=U(VW)$
        - 新问题：矩阵乘法结合的顺序
    - n个矩阵相乘
        - 有一系列矩阵按照顺序排序
        - 每个矩阵的行数=前一个矩阵列数
        - n个矩阵相乘也称为矩阵乘法

- 矩阵乘法问题
    - 输入：
        - $n$ 个矩阵组成的矩阵链 $U_{1..n}=<U_1,U_2,..,U_n>$
        - 矩阵链 $U_{1..n}$ 对应的维度数分别是 $p_0,p_1,...p_n$ , $U_i$ 的维度数是 $p_{i-1}\times p_i$
    - 输出：
        - 找到一种加括号的方式，以确定矩阵乘法的计算顺序，使得最小化矩阵链标量乘法的次数
- 问题结构分析
    - 给出问题表示
        - $D[i,j]$：计算矩阵链$U_{i,..j}$ 所需要的标量的乘法的最小数目
    - 明确原始问题
        - $D[1,n]$：计算矩阵链 $U_{1,..n}$ 所需要的乘法的最小次数

- 递推关系建立：分析最优子结构
    - 对矩阵链 $U_{i,..j}$ , 求解$D[i,j]$ $$U_i,...U_k,U_{k+1}..U_j$$
    - $D[i,j]=D[i,k]+D[k+1,j]+p_{i-1}p_k p_k$
    - 对每个位置 $k$ ,$ i\leq k \leq j$
        - $D[i,j]=D[i,k]+D[k+1,j]+p_{i-1}p_k p_k$
    - 枚举所有的 $k$ ,得到递推式 
        - $D[i,j]=\min_{i\leq k <j>}(D[i,k]+D[k+1,j]+p_{i-1}p_k p_k)$

- 自底向上计算：确定计算顺序
    - 初始化
        - $i=j$时，矩阵链只有一个矩阵，乘法次数是0
    - 递推公式
        - $D[i,j]=\min_{i\leq k <j>}(D[i,k]+D[k+1,j]+p_{i-1}p_k p_k)$
    

- 最优方案追踪：输出最优方案
    - 根据追踪数组，递归输出方案

- 伪代码

<div align="center">
<img src="./MCM.svg" width="600" alt="矩阵乘法" />
</div> 