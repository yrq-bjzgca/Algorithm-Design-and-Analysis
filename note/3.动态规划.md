# 动态规划
## 一般步骤
- 问题结构分析
    - 给出问题表示，明确原始问题
- 递推关系建立
    - 分析最优结果，构造递推公式
- 自底向上计算
    - 确定计算顺序，依次求解问题
- 最优方案追踪
    - 记录决策过程，输出最优方案
## 经典问题
### 0-1背包问题

- 问题背景：超市允许顾客使用一个体积为13的背包，选择一件或者多件商品带走

| 商品 | 价格 | 体积 |
|---------|---------|---------|
| 啤酒   |  24  |  10  |
| 汽水   |  2   |  3   |
| 饼干   |  9   |  4   |
| 面包   |  10  |  5   |
| 牛奶   |  9   |  4   |

- 名称：0-1背包问题(0-1Knapsack Probelm)
- 输入： 
    - $n$ 个商品组成集合 $O$ ,每个商品都有两个属性 $v_i$ 和 $p_i$ ,分别表示体积和价格
    - 背包的容量为 $C$

- 输出：
    - 求解一个商品子集 $S\subseteq  O$  ，令 

$$
\begin{aligned}
\max \quad & \sum_{i\in S} p_i \quad \text{(优化目标)}\\
\text{s.t.} \quad & \sum_{i \in S} v_i \leq C \quad \text{(约束条件)}
\end{aligned}
$$

#### 策略
- 策略1：按照商品价格从低到高进行排序，优选挑选价格高的商品（非最优解）
- 策略2：按照商品体积从小到大排序，优先挑选体积小的商品（非最优解）
- 策略3：按照商品价值与体积的比由低到高进行排序，优先挑选比值高的商品（非最优解）
- 蛮力枚举
    - 思路：任意选一件商品，之后遍历选第二件...,，同时检查体积约束
    - 一共有 $2^n-1$ 种情况，检查体积约束

<div align="center">
<img src="./knapsackSR.svg" width="600" alt="knapsackSR" />
</div>

*存在的问题：重复求解大量子问题*

<div align="center">
<img src="./knapsack_problem.svg" width="600" alt="knapsack_problem" />
</div>

- 带有备忘录的递归
    - 在递归结果里加入一个备忘录 $P[i,c]\leftarrow P$
    - 在递归之前判断是不是计算过 $if P[i,c] \neq NULL$

<div align="center">
<img src="./knapsackMR.svg" width="600" alt="knapsackMR" />
</div>

- 动态规划：自底向上
*递推公式*
$$
P[i,c]=\max{\{P[i-1,c-v[i]]+p[i],P[i-1,c]\}}
$$
- 公式解释
    -  $P[i-1,c]$ 表示不选择商品 $i$ 
    -  $P[i-1,c-v[i]]+p[i]$ 表示选择商品 $i$ 

*记录递推过程*
$$
Rec[i,c]=\begin{cases}
1,\text{选择商品}\\
0,\text{不选择商品}
\end{cases}
$$

倒序判断是否选择商品

根据选择结果，确定最优子问题

#### 伪代码

<div align="center">
<img src="./knapsackDP.svg" width="600" alt="knapsackDP" />
</div>

``` python
def KnasackDP(n, p, v, C):
    """
    0/1背包问题的动态规划解决方案
    
    参数说明:
        n: 物品数量 (int)
        p: 物品价值列表 (list)，p[i]表示第i个物品的价值
        v: 物品体积列表 (list)，v[i]表示第i个物品的体积
        C: 背包总容量 (int)
    
    返回:
        最大价值 (int)
    
    算法核心思想:
        构建DP表P[i][c]，表示考虑前i+1个物品、在容量c限制下的最大价值
        Rec[i][c]记录是否选择第i个物品，用于后续回溯
    """
    
    # ------------------------------------------------------------------
    # 阶段1: 初始化DP表和选择记录表
    # ------------------------------------------------------------------
    # 修复1: DP表维度为 n x (C+1)
    # 因为有n个物品，每个物品对应一行；容量范围是0到C，共C+1列
    # 这种设计将第0行用于第一个物品，而不是传统DP的"0个物品"状态
    P = [[0] * (C + 1) for _ in range(n)]    # P[i][c] = 最大价值
    Rec = [[0] * (C + 1) for _ in range(n)]  # Rec[i][c] = 1表示选择第i个物品
    
    # ------------------------------------------------------------------
    # 阶段2: 初始化第一个物品（物品0）
    # ------------------------------------------------------------------
    # 为什么要单独处理第一个物品？
    # 因为DP表的第0行对应的就是物品0，没有"前0个物品"的行
    # 对于容量c >= 物品0体积的情况，可以直接放入物品0
    for c in range(v[0], C + 1):  # 遍历从物品0体积到最大容量的所有容量
        P[0][c] = p[0]            # 放入物品0，获得其价值
        Rec[0][c] = 1             # 标记为"选择"
    
    # ------------------------------------------------------------------
    # 阶段3: 填充DP表（动态规划核心）
    # ------------------------------------------------------------------
    # 遍历物品1到物品n-1（共n-1个物品）
    # i是物品的索引，也是DP表的行索引
    for i in range(1, n):
        # 遍历所有可能的容量c（从1到C）
        # c是背包的当前容量限制，也是DP表的列索引
        for c in range(1, C + 1):
            
            # 情况A: 尝试放入当前物品i
            # 条件1: v[i] <= c 表示物品i能装得下
            # 条件2: p[i] + P[i-1][c-v[i]] > P[i-1][c] 表示放入后总价值更高
            # P[i-1][c-v[i]] 表示在剩余容量下的最优价值
            if v[i] <= c and (p[i] + P[i-1][c-v[i]] > P[i-1][c]):
                P[i][c] = p[i] + P[i-1][c-v[i]]  # 选择物品i后的总价值
                Rec[i][c] = 1                     # 标记为"选择"
            
            # 情况B: 不放入当前物品i
            # 要么装不下，要么放入后价值不划算
            else:
                P[i][c] = P[i-1][c]  # 直接继承前一状态的价值
                Rec[i][c] = 0        # 标记为"不选择"
    
    # ------------------------------------------------------------------
    # 阶段4: 回溯找出选择了哪些物品
    # ------------------------------------------------------------------
    # 从DP表的右下角开始回溯，即考虑所有物品、容量为C的状态
    K = C  # K表示当前剩余容量
    
    # 从最后一个物品倒序遍历到第一个物品
    # range(n-1, -1, -1) 生成: n-1, n-2, ..., 0
    selected = []  # 存储被选中的物品索引
    for i in range(n-1, -1, -1):
        if Rec[i][K] == 1:  # 如果Rec[i][K]==1，说明物品i被选中
            selected.append(i)  # 记录物品索引
            print(f"选取物品{i}")  # 打印选择信息
            K = K - v[i]  # 剩余容量减少该物品的体积
        else:
            print(f"不选取物品{i}")  # 打印不选择信息
    
    # ------------------------------------------------------------------
    # 阶段5: 返回结果
    # ------------------------------------------------------------------
    # P[n-1][C] 是DP表的右下角，表示考虑所有n个物品、容量为C时的最大价值
    max_value = P[n-1][C]
    print(f"\n最大价值: {max_value}")
    
    return max_value


# ------------------------------------------------------------------
# 测试代码
# ------------------------------------------------------------------
if __name__ == "__main__":
    # 物品体积列表 (索引0到4对应5个物品)
    v = [10, 3, 4, 5, 4]
    
    # 物品价值列表
    p = [24, 2, 9, 10, 9]
    
    # 背包总容量
    C = 13
    
    # 物品数量
    n = 5
    
    # 调用函数并打印结果
    result = KnasackDP(n, p, v, C)
    print(f"函数返回值: {result}")

```

#### 动态规划一般步骤
-问题结构分析
    - 给出问题表示
        -  $P[i,c]$ :前 $i$ 个商品可选、背包容量为 $c$ 时的最大总价格
    - 明确原始问题
        -  $P[n,C]$ :前 $n$ 个商品可选，背包容量为 $C$ 时的最大总价格
- 递推关系建立
    - 分析最优子结构
        - 问题的最优解由相关子问题最优解**组合构成** ，子问题可以**独立求解**
    - 构造递推式
        - $P[i,c]=\max{\{P[i-1,c-v[i]]+p[i],P[i-1,c]\}}$
- 自底向上计算
    - 确定计算顺序
        - 初始化
            - 容量为0的时候： $P[i,0]=0$ 没有商品的时候 $P[0,c]=0$
        -  $P[i,c]$ 依赖于子问题 $P[i-1,c-v_i]$ 和 $P[i-1,c]$ 
    - 依次求解问题

- 最优方案追踪
    - 记录决策过程
        -   $
            Rec[i,c]=\begin{cases}
            1,\text{选择商品}\\
            0,\text{不选择商品}
            \end{cases}
            $
    - 输出最优方案
        - 倒序判断是否选择商品
        -  $Rec[i,c]=1$时，选择商品 $i$ ,考察子问题 $P[i-1,c-v_i]$
        -  $Rec[i,c]=0$时，不选商品 $i$ ,考察子问题 $P[i-1,c]$


### 最大子数组问题II

- 问题：寻找数组  $X$ 最大的非空子数组,（Max continuous Subarray,MCS）
    - 输入：
        - 给定一个数组 $X[1..n]$ ,对于任意一对数组下标为 $l,r(l\leq r)$ 的非空数组，其和记为 $S[l,r]=\sum_{i=l}^{r}X[i]$
    - 输出：
        - 求出 $S(l,r)$ 的最大值， 记为 $S_{max}$
    - 子序列：将给定序列中零个或者多个元素(如字符)去掉的结果
    - 子串：给定序列中零个或者多个**连续**的元素(如字符)组成的子序列
#### 策略
- 蛮力枚举
    - 数组 $X[1,n]$ ,其所有的下标 $l,r(l \leq r)$ 组合分为以下俩种情况
        - 当 $l=r$ 时， 一共有 $C_{n}^{1}$ 种组合
        - 当 $l<r$ 时， 一共有 $C_{n}^{2}$ 种组合
    - 枚举 $C_{n}^{1} + C_{n}^{2}$ 种下标 $l,r$ 组合，求出最大子数组之和
- 优化枚举

- 分而治之

- 动态规划
    - 问题结构分析：
        -  $D_i$:以 $X[i]$ 为开头的最大子数组和
    - 明确原始问题：
        -  $S_{max}=\max_{1\leq i\leq n}{\{D[i]\}}$
    - 递推关系建立:分析最优子结构
        - $D_i$:以 $X[i]$ 开头的最大子数组和
        - 情况1： $D_{i+1}>0$  , $D[i]=D[i+1]+X[i]$
        - 情况2： $D_{i+1}\leq 0$  $D[i]=X[i]$
    - 递推关系建立:构造递推公式
        -   $$
            D[i]=\begin{cases}
            X[i]+D[i+1] , &  \text{if}\quad D[i+1]>0\\
            X[i] , &  \text{if}\quad D[i+1]\leq 0
            \end{cases}
            $$
    - 自底向上计算：确定计算顺序
        - 初始化：
            - $D[n]=X[n]$
        - 递推公式：
            -   $$
                D[i]=\begin{cases}
                X[i]+D[i+1] , &  \text{if}\quad D[i+1]>0\\
                X[i] , &  \text{if}\quad D[i+1]\leq 0
                \end{cases}
                $$
    - 最优方案追踪：记录决策过程
        - 构造追踪数组 $Rec[1..n]$ 
            - 情况1：结尾相同
                - $Rec[i]=Rec[i+1]$
            - 情况2：结尾不同
                - $Rec[i]=i$ 
        - 从子问题种查找最优解
            - 最大子数组开头位置: $i$ 
            - 最大子数组结尾位置: $Rec[i]$ 

- 伪代码
<div align="center">
<img src="./mcs-5.svg" width="600" alt="动态规划MCS" />
</div>

```python
def max_continuous_subarray_dp(X, n):
    """
    使用动态规划求解最大连续子数组和问题（Kadane算法变种）
    
    参数:
        X: 整数列表，表示给定的数组
        n: 数组长度
    
    返回:
        Smax: 最大连续子数组的和
        l: 最大子数组的左边界索引（0-based）
        r: 最大子数组的右边界索引（0-based）
    
    算法思路:
        反向遍历数组，D[i]表示从位置i开始的最大子数组和。
        如果D[i+1]为正，则合并；否则从i重新开始。
        Rec[i]记录从i开始的子数组的右边界。
    """
    
    # ------------------------------------------------------------------
    # 阶段1: 初始化DP数组和记录数组
    # ------------------------------------------------------------------
    # D[i] 表示从位置 i 开始的最大连续子数组和
    # 为方便处理边界，D长度为n+1，D[n] = 0作为哨兵
    # D[n] = 0 表示数组末尾之外的子数组和为0
    D = [0] * (n + 1)
    
    # Rec[i] 记录从 i 开始的子数组的右边界（结束索引）
    # 即：从 i 到 Rec[i] 的子数组和为 D[i]
    Rec = [0] * (n + 1)
    
    # ------------------------------------------------------------------
    # 阶段2: 反向动态规划（从右往左计算）
    # ------------------------------------------------------------------
    # 为什么反向？因为 D[i] 依赖 D[i+1]（右边的结果）
    # 循环 i 从 n-1 递减到 0（包含0）
    for i in range(n - 1, -1, -1):
        
        # 情况A：如果右边子数组的和为正，则合并扩展
        # D[i+1] 表示从 i+1 开始的子数组和
        if D[i + 1] > 0:
            # 合并：从i开始的和 = 当前元素X[i] + 右边正数和
            D[i] = X[i] + D[i + 1]
            # 右边界继承：从i开始的子数组右边界 = 从i+1开始的右边界
            Rec[i] = Rec[i + 1]
        
        # 情况B：如果右边子数组的和为非正，则重新开始
        else:
            # 重新开始：从i开始的和就是X[i]本身
            D[i] = X[i]
            # 右边界重置为i（子数组只有当前元素）
            Rec[i] = i
    
    # ------------------------------------------------------------------
    # 阶段3: 在DP数组中查找全局最大值
    # ------------------------------------------------------------------
    # 初始设置：假设最大值在索引0处
    # Smax 存储最大和，l和r存储对应的左右边界
    Smax = D[0]    # 初始最大和
    l = 0          # 初始左边界
    r = Rec[0]     # 初始右边界
    
    # 遍历所有位置 i 从 1 到 n-1
    for i in range(1, n):
        # 如果找到更大的和
        if Smax < D[i]:
            # 更新最大值和对应的边界
            Smax = D[i]      # 更新最大和
            l = i            # 更新左边界为当前i
            r = Rec[i]       # 更新右边界为Rec[i]记录的边界
    
    # ------------------------------------------------------------------
    # 阶段4: 返回结果
    # ------------------------------------------------------------------
    return Smax, l, r


# ------------------------------------------------------------------
# 主程序测试
# ------------------------------------------------------------------
if __name__ == "__main__":
    # 测试数组
    X = [1, -2, 4, 5, -2, 8, 3, -2, 6, 3, 7, -1]
    n = len(X)
    
    # 打印基本信息
    print(f"数组长度: {n}")
    print(f"数组内容: {X}")
    
    # 调用函数并获取结果
    result = max_continuous_subarray_dp(X, n)
    
    # ------------------------------------------------------------------
    # 阶段5: 结果验证与输出
    # ------------------------------------------------------------------
    Smax, l, r = result
    
    # 打印结果
    print(f"最大子数组和: {Smax}")
    print(f"子数组范围: X[{l}:{r+1}]")
    print(f"子数组内容: {X[l:r+1]}")
    
    # 手动验证
    total = sum(X[l:r+1])
    print(f"手动验证和: {total}")
```

### 最长公共子序列

- 子序列：给定序列中零个或多个元素(如字符)去掉之后得到的结果
- 形式化定义：
    - 输入：
        - 序列 $X=<x_1,x_2,...,x_n>$ 和序列 $Y=<y_1,y_2,...,y_m>$ 
    - 输出：
        - 求解一个公共子序列 $Z=<z_1,z_2,...,z_l>$
        $$\max|z|$$
        $$s.t.<z_1,z_2,...z_l>=<x_{i1},x_{i2},...,x_{il}>=<y_{j1},y_{j2},...,y_{jl}>$$
        $$1\leq i_1\leq i_2,....i_l\leq n;1\leq j_1\leq j_2,...\leq j_l\leq m$$
#### 策略
- 动态规划
    - 问题结构分析
        - 给出问题表示：
            -  $C[i,j]$ : $X[1...i]$ 和 $Y[1,...j]$ 的最长公共子序列长度
        - 明确原始问题：
            -  $C[n,m]$ : $X[1,..n]$ 和 $Y[1..m]$ 的最长公共子序列长度
    - 分析最优子结构
        - 考察末尾字符
            -  当 $x_i \neq y_j$ , $C[i,j]=\max{\{C[i-1,j],C[i,j-1]\}}$
            -  当 $x_i = y_j$ , $C[i,j]=C[i-1,j-1]+1$
        - 递推关系式建立
            -   $$
                C[i,j]=\begin{cases}
                \max{\{C[i-1,j],C[i,j-1]\}},& x_i \neq y_j\\
                C[i-1,j-1]+1,& x_i=y_j
                \end{cases}
                $$
        - 自底向上计算
            - 初始化
                - $C[i,0]=C[0,j]=0$， 某序列长度为0的时候，最长公共子序列长度为0 
            - 递推公式
                - $$C[i,j]=\begin{cases}
                    \max{\{C[i-1,j],C[i,j-1]\}},& x_i \neq y_j\\
                    C[i-1,j-1]+1,& x_i=y_j
                    \end{cases}
                    $$
            - 构造追踪数组 $rec[1..n]$ ,记录子问题的来源
                -   $$
                    rec[i,j]=\begin{cases}
                    LU,& \text{if} C[i,j]=C[i-1,j-1]+1\\
                    U,&\text{if}C[i,j]=C[i-1,j]\\
                    L,&\text{if}C[i,j]=C[i,j-1]
                    \end{cases}
                    $$
                - 最长公共子序列在 $X[1,...,i-1]$ 和 $Y[1,..j]$中
                - 最长公共子序列末尾是 $X[i]=Y[j]$
- 伪代码
<div align="center">
<img src="./LCS.svg" width="600" alt="LCS" />
</div>

```python
def Longest_Common_Subsequence(X, Y):
    """
    计算两个字符串的最长公共子序列 (LCS - Longest Common Subsequence)
    与子串不同，子序列不要求字符连续，只要求相对顺序保持不变
    
    参数:
        X: 字符串1
        Y: 字符串2
    
    返回:
        C: DP表，C[i][j]表示X[0:i]和Y[0:j]的LCS长度
        Rec: 记录表，标记每一步的路径方向，用于后续回溯构造LCS
    """
    n = len(X)  # 字符串X的长度
    m = len(Y)  # 字符串Y的长度
    
    # ------------------------------------------------------------------
    # 阶段1: 初始化DP表和记录表
    # ------------------------------------------------------------------
    # C[i][j] 表示 X[0:i] 和 Y[0:j] 的最长公共子序列长度
    # 需要 (n+1) x (m+1) 的二维表，额外的一行一列处理空字符串的边界情况
    # i=0 表示X为空字符串, j=0 表示Y为空字符串，此时LCS长度为0
    C = [[0] * (m + 1) for _ in range(n + 1)]
    
    # Rec[i][j] 记录到达C[i][j]的路径方向，用于回溯时重构LCS
    # "LU" 表示来自左上角 (i-1, j-1)，说明X[i-1]==Y[j-1]且该字符被选中
    # "U"  表示来自上方 (i-1, j)，说明跳过X[i-1]这个字符
    # "L"  表示来自左方 (i, j-1)，说明跳过Y[j-1]这个字符
    Rec = [[""] * (m + 1) for _ in range(n + 1)]
    
    # ------------------------------------------------------------------
    # 阶段2: 填充DP表（动态规划核心）
    # ------------------------------------------------------------------
    # 遍历字符串X的每个字符（从1开始，因为第0行是边界）
    for i in range(1, n + 1):
        
        # 遍历字符串Y的每个字符
        for j in range(1, m + 1):
            
            # 情况1: 当前字符匹配
            # X[i-1] 是字符串X的第i个字符（0-based索引）
            # Y[j-1] 是字符串Y的第j个字符（0-based索引）
            if X[i - 1] == Y[j - 1]:
                # 如果字符匹配，LCS长度 = 左上角值 + 1
                # 因为当前字符可以加入公共子序列
                C[i][j] = C[i - 1][j - 1] + 1
                Rec[i][j] = "LU"  # 标记方向为左上角
                
            # 情况2: 当前字符不匹配
            # 需要比较两个方向：跳过X[i-1] 或 跳过Y[j-1]
            # 选择能使LCS更长的那个方向
            elif C[i - 1][j] > C[i][j - 1]:
                # 如果上方单元格的值更大，说明跳过X[i-1]更有利
                C[i][j] = C[i - 1][j]
                Rec[i][j] = "U"  # 标记方向为上方
                
            else:
                # 否则左方单元格的值更大或相等，跳过Y[j-1]
                C[i][j] = C[i][j - 1]
                Rec[i][j] = "L"  # 标记方向为左方
    
    # ------------------------------------------------------------------
    # 阶段3: 返回结果
    # ------------------------------------------------------------------
    return C, Rec


def Print_LCS(Rec, X, i, j):
    """
    根据记录表Rec回溯并打印最长公共子序列
    
    参数:
        Rec: 记录表（来自Longest_Common_Subsequence函数）
        X: 字符串X
        i: 当前行索引（从len(X)开始回溯）
        j: 当前列索引（从len(Y)开始回溯）
    """
    # ------------------------------------------------------------------
    # 阶段4: 递归回溯（从右下角向左上角追溯）
    # ------------------------------------------------------------------
    # 边界条件：如果任一索引为0，表示已到达空字符串，递归结束
    if i == 0 or j == 0:
        return
    
    # 情况1: 方向为"LU"，表示X[i-1]==Y[j-1]且该字符属于LCS
    if Rec[i][j] == "LU":
        # 先递归处理左上角（处理前面的子问题）
        Print_LCS(Rec, X, i - 1, j - 1)
        # 打印当前字符（注意是X[i-1]，因为i是DP表索引）
        # end='' 表示不换行，字符会连续输出
        print(X[i - 1], end='')
    
    # 情况2: 方向为"U"，表示跳过X[i-1]
    # 只需要向上递归（i-1, j保持不变）
    elif Rec[i][j] == "U":
        Print_LCS(Rec, X, i - 1, j)
    
    # 情况3: 方向为"L"，表示跳过Y[j-1]
    # 只需要向左递归（i保持不变, j-1）
    elif Rec[i][j] == "L":
        Print_LCS(Rec, X, i, j - 1)


# ------------------------------------------------------------------
# 主程序测试
# ------------------------------------------------------------------
if __name__ == "__main__":
    # 测试用例
    X = "ABCBDAB"
    Y = "BDCABA"
    
    # 计算LCS
    C, Rec = Longest_Common_Subsequence(X, Y)
    
    # 打印DP表（调试用）
    print("DP表 C:")
    for row in C:
        print(row)
    
    print("\n记录表 Rec:")
    for row in Rec:
        print(row)
    
    # 获取字符串长度作为回溯起点
    i = len(X)
    j = len(Y)
    
    # 打印最终结果
    print(f"\n字符串X: {X}")
    print(f"字符串Y: {Y}")
    print(f"最长公共子序列: ", end='')
    Print_LCS(Rec, X, i, j)
    print()  # 换行
    print(f"长度: {C[i][j]}")
    
    # 验证结果
    print(f"\n验证: DP表右下角值 C[{i}][{j}] = {C[i][j]}")
```

### 最长公共子串问题
- 基本概念：
    - 子序列：将给定的序列中的0个或者多个元素(如字符)去掉之后的得到的结果
    - 子串：给定序列中0个或者多个连续的元素(如字符)组成的子序列

- 形式化定义：
    - 输入：
        - 序列 $X=<x_1,x_2,...,x_n>$ 和序列 $Y=<y_1,y_2,...,y_m>$ 
    - 输出：
        - 求解一个公共子串 $Z=<z_1,z_2,...,z_l>$
        $$\max|z|$$
        $$s.t.<z_1,z_2,...z_l>=<x_{i},x_{i+1},...,x_{i+l-1}>=<y_{j},y_{j1},...,y_{j+l-1}>$$
        $$1\leq i \leq n-l+1;1\leq j\leq m-l+1$$

#### 策略
- 蛮力枚举
    - 序列$X$和序列$Y$各选择一个位置
    - 依次检查元素是否匹配
        -元素相等则继续匹配
- 动态规划
    - 问题结构分析
        - $C[i,j]$
            -  $X[1,..,i]$ 和 $Y[1,...,j]$ 中,以 $x_i$ 和 $y_i$ 结尾的最长公共子串 $Z[1,...,l]$ 的长度
        - 明确原始问题
            -  $P_{max}=\max_{1\leq i\leq n,1\leq j\leq m}{\{C[i,j]\}}$
            - $X[1,..,n]$ 和 $Y[1..m]$ 中最长公共子串的长度
    - 递推关系建立
        - 分析最优子结构
        - 构造递推公式
        $$
        C[i,j]=\begin{cases}
        0&x_i\neq y_j\\
        C[i-1,j-1]+1&x_i=y_j
        \end{cases}
        $$
    - 自底向上计算：确定计算顺序
        - 初始化
            - $C[i,0]=C[0,j]=0$
            - 某序列长度为0的时候，最长公共子串为0
        - 递推公式
        $$
        C[i,j]=\begin{cases}
        0&x_i\neq y_j\\
        C[i-1,j-1]+1&x_i=y_j
        \end{cases}
        $$
        - 原始问题
            - $p_{max}=\max_{1\leq i \leq n,1\leq j\leq m}{\{C[i,j]\}}$
    - 最优方案追踪
        - 记录决策过程
            - 最长公共子串末尾位置为 $p_{max}$
            - 最长公共子串长度为 $l_{max}$
    - 输出最优方案
        - 最长公共子串 $<x_{p_{max}-l+1},...x_{p_{max}}>$
- 伪代码
<div align="center">
<img src="./LCS-1.svg" width="600" alt="公共子串" />
</div>

```python
def Longest_common_substring(X, Y):
    """
    求解两个字符串的最长公共子串（Longest Common Substring）
    与子序列不同，子串要求字符在原字符串中连续出现
    
    参数:
        X: 字符串1
        Y: 字符串2
    
    返回:
        lmax: 最长公共子串的长度
        pmax: 最长公共子串在X中的结束位置（0-based索引）
    """
    n = len(X)  # 字符串X的长度
    m = len(Y)  # 字符串Y的长度
    
    # ------------------------------------------------------------------
    # 阶段1: 初始化DP表
    # ------------------------------------------------------------------
    # 创建 (n+1) x (m+1) 的二维数组C
    # C[i][j] 表示以 X[i-1] 和 Y[j-1] 结尾的最长公共子串的长度
    # 额外的一行和一列（i=0或j=0）作为边界，初始化为0，简化边界条件处理
    C = [[0] * (m + 1) for _ in range(n + 1)]
    
    lmax = 0  # 记录全局最大长度
    pmax = 0  # 记录最长公共子串在X中的结束索引
    
    # ------------------------------------------------------------------
    # 阶段2: 填充DP表（动态规划核心）
    # ------------------------------------------------------------------
    # 遍历字符串X的每个字符，i是DP表的行索引（从1开始）
    # i-1 才是对应字符在X中的实际索引
    for i in range(1, n + 1):
        
        # 遍历字符串Y的每个字符，j是DP表的列索引（从1开始）
        # j-1 才是对应字符在Y中的实际索引
        for j in range(1, m + 1):
            
            # 如果当前字符匹配
            # X[i-1] 是字符串X中索引为i-1的字符
            # Y[j-1] 是字符串Y中索引为j-1的字符
            if X[i - 1] == Y[j - 1]:
                # 当前公共子串长度 = 左上角值 + 1
                # 因为字符匹配，所以长度在之前的公共子串基础上+1
                C[i][j] = C[i - 1][j - 1] + 1
                
                # 更新全局最大值
                # 如果当前子串长度大于已知最大长度
                if C[i][j] > lmax:
                    lmax = C[i][j]      # 更新最大长度
                    pmax = i - 1        # 记录实际字符索引（i-1）
            
            # 如果字符不匹配，当前公共子串长度重置为0
            # 因为子串要求连续，一旦断开就要重新开始
            else:
                C[i][j] = 0
    
    # ------------------------------------------------------------------
    # 阶段3: 返回结果
    # ------------------------------------------------------------------
    # lmax: 最长公共子串的长度
    # pmax: 该子串在X中的结束位置（索引）
    return lmax, pmax


def print_LCS(X, lmax, pmax):
    """
    打印最长公共子串
    
    参数:
        X: 原始字符串
        lmax: 子串长度
        pmax: 子串在X中的结束索引
    """
    # 如果长度为0，说明没有公共子串
    if lmax == 0:
        print("没有公共子串")
        return
    
    # ------------------------------------------------------------------
    # 阶段4: 提取并打印子串
    # ------------------------------------------------------------------
    # 通过切片从X中提取子串
    # 起始位置 = pmax - lmax + 1
    # 结束位置 = pmax + 1 （Python切片是左闭右开）
    # 例如: X="ABCADBB", 最长公共子串是"BB"
    # pmax=6, lmax=2, 切片X[5:7]得到"BB"
    
    # 修复点: 循环范围应包含pmax，所以是pmax+1
    for i in range(pmax - lmax + 1, pmax + 1):
        # 打印字符但不换行，end=''使所有字符连续输出
        print(X[i], end='')
    
    # 打印完成后输出一个换行符，美化输出
    print()


# ------------------------------------------------------------------
# 主程序测试
# ------------------------------------------------------------------
if __name__ == "__main__":
    X = "ABCADBB"
    Y = "BCEDBB"
    
    # 求解最长公共子串
    lmax, pmax = Longest_common_substring(X, Y)
    
    # 打印结果
    print(f"字符串X: {X}")
    print(f"字符串Y: {Y}")
    print(f"最长公共子串长度: {lmax}")
    print(f"在X中的位置: [{pmax-lmax+1}:{pmax+1}]")
    print(f"子串内容: ", end='')
    print_LCS(X, lmax, pmax)
```
### 编辑距离问题
- 问题背景：输入法自动更正
- 基本思想：字符串A -编辑操作-> 字符串B
- 基本操作：删除、插入、替换
- 形式化定义：
    - 问题名称：Minimum Edit Distance,MED
    - 输入：长度为 $n$ 的字符串 $s$, 长度为 $m$ 的字符串 $t$
    - 输出：求出一组编辑操作 $O=<e_1,e_2,...e_d>$,令
    $$\min{|O|}$$
    $$s.t.字符串s经过O操作之后满足s=t$$
- 问题结构分析:
    - 给出问题表示
        - $D[i,j]$: 字符串$s[1..i]$变为$t[1..j]$的最小编辑距离
    - 明确原始问题：
        - $D[n,m]$:字符串$s[1..n]$变为$t[1..m]$的最小编辑距离
-  递推关系建立：
    - 最长公共子序列
        - 如果 $s_i \neq t_j$
        - 如果 $s_i=t_j$
    - 考察末尾元素：删除、插入、替换
        - 删除：$$ D[i,j]=D[i-1,j]+1$$
        - 插入：$$ D[i,j]=D[i,j-1]+1$$
        - 替换: $$ D[i,j]=D[i-1,j-1]+\begin{cases}
        0,& \text{if} \quad s[i] = t[j]\\
        1,& \text{if} \quad s[i]\neq t[j]\\
        \end{cases}$$
    - 构造递推公式
    $$D[i,j]=\begin{cases}
    D[i-1,j]+1 &删除\\
    D[i,j-1]+1 &插入\\
    D[i-1,j-1]+\begin{cases}
    0,& \text{if} \quad s[i] = t[j] \\
    1,& \text{if} \quad s[i]\neq t[j]
    \end{cases}
    \end{cases}$$
    - 初始化
        - $D[i,0]=i$
            - 把长度为 $i$ 的串变成空串需要 $i$ 次操作（删除）
        - $D[0,j]=j$
            - 把长度为 $j$ 的空串变成串需要 $j$ 次操作（插入）
    - 记录决策过程
        - 追踪数组，输出最小编辑操作

- 伪代码
<div align="center">
<img src="./MED.svg" width="600" alt="编辑距离" />
</div>

```python
def Minimum_Edit_Distance(s, t):
    """
    计算两个字符串之间的最小编辑距离（Levenshtein距离）
    支持的操作：插入、删除、替换（替换代价为1）
    
    参数:
        s: 源字符串
        t: 目标字符串
    
    返回:
        D: DP表，D[i][j]表示s[0:i]转换为t[0:j]的最小编辑距离
        Rec: 记录表，标记每一步的最优操作方向，用于回溯
    """
    n = len(s)  # 源字符串长度
    m = len(t)  # 目标字符串长度
    
    # ------------------------------------------------------------------
    # 阶段1: 初始化DP表和记录表
    # ------------------------------------------------------------------
    # D[i][j] 表示将 s[0:i]（前i个字符）转换为 t[0:j]（前j个字符）的最小编辑距离
    # 表格大小为 (n+1) x (m+1)，额外的一行一列处理空字符串边界
    # i=0 表示s为空字符串, j=0 表示t为空字符串，此时转换距离为i或j
    D = [[0] * (m + 1) for _ in range(n + 1)]
    
    # Rec[i][j] 记录到达D[i][j]的最优操作方向
    # "LU" 表示替换/匹配操作（从(i-1,j-1)来）
    # "U"  表示删除操作（从(i-1,j)来）
    # "L"  表示插入操作（从(i,j-1)来）
    Rec = [[""] * (m + 1) for _ in range(n + 1)]
    
    # ------------------------------------------------------------------
    # 阶段2: 初始化边界条件
    # ------------------------------------------------------------------
    # 将空字符串s（i=0）转换为非空字符串t（j>0）：需要j次插入操作
    for j in range(m + 1):
        D[0][j] = j
        if j > 0:  # 第0列不需要标记方向（已经是边界）
            Rec[0][j] = "L"  # 插入操作，从(0,j-1)来
    
    # 将非空字符串s（i>0）转换为空字符串t（j=0）：需要i次删除操作
    for i in range(n + 1):
        D[i][0] = i
        if i > 0:  # 第0行不需要标记方向
            Rec[i][0] = "U"  # 删除操作，从(i-1,0)来
    
    # ------------------------------------------------------------------
    # 阶段3: 填充DP表（动态规划核心）
    # ------------------------------------------------------------------
    # 遍历源字符串s的每个字符（行）
    for i in range(1, n + 1):
        # 遍历目标字符串t的每个字符（列）
        for j in range(1, m + 1):
            
            # 如果当前字符相同，则无需编辑（替换代价c=0）
            # 如果不同，则需要替换（替换代价c=1）
            cost_replace = 0 if s[i - 1] == t[j - 1] else 1
            
            # 三种可能的操作：
            # 1. 替换/匹配：从D[i-1][j-1]来，加上替换代价
            replace = D[i - 1][j - 1] + cost_replace
            
            # 2. 删除：从D[i-1][j]来（删除s[i-1]），代价+1
            delete = D[i - 1][j] + 1
            
            # 3. 插入：从D[i][j-1]来（插入t[j-1]），代价+1
            insert = D[i][j - 1] + 1
            
            # 选择三种操作中代价最小的
            min_cost = min(replace, delete, insert)
            
            # 根据最小代价更新DP表和记录表
            if replace == min_cost:
                D[i][j] = replace
                Rec[i][j] = "LU"  # 替换/匹配操作
            elif delete == min_cost:
                D[i][j] = delete
                Rec[i][j] = "U"   # 删除操作
            else:
                D[i][j] = insert
                Rec[i][j] = "L"   # 插入操作
    
    # ------------------------------------------------------------------
    # 阶段4: 返回结果
    # ------------------------------------------------------------------
    return D, Rec


def Print_MED(Rec, s, t, i, j):
    """
    根据记录表Rec回溯并打印具体的编辑操作序列
    
    参数:
        Rec: 记录表（来自Minimum_Edit_Distance函数）
        s: 源字符串
        t: 目标字符串
        i: 当前行索引（从len(s)开始回溯）
        j: 当前列索引（从len(t)开始回溯）
    """
    # ------------------------------------------------------------------
    # 阶段5: 递归回溯（从右下角向左上角追溯）
    # ------------------------------------------------------------------
    # 边界条件：如果两个索引都为0，表示已回到起点，递归结束
    if i == 0 and j == 0:
        return
    
    # 情况1: 方向为"LU"，表示替换或匹配操作
    if Rec[i][j] == "LU":
        # 先递归处理左上角（处理前面的子问题）
        Print_MED(Rec, s, t, i - 1, j - 1)
        # 判断具体操作类型
        if s[i - 1] == t[j - 1]:
            print(f"字符'{s[i-1]}'匹配，无需操作")
        else:
            print(f"将'{s[i-1]}'替换为'{t[j-1]}'")
    
    # 情况2: 方向为"U"，表示删除操作
    # 从(i-1,j)转移到(i,j)，需要删除s[i-1]
    elif Rec[i][j] == "U":
        # 先递归处理上方（处理前面的子问题）
        Print_MED(Rec, s, t, i - 1, j)
        # 打印删除操作
        print(f"删除'{s[i-1]}'")
    
    # 情况3: 方向为"L"，表示插入操作
    # 从(i,j-1)转移到(i,j)，需要插入t[j-1]
    else:
        # 先递归处理左方（处理前面的子问题）
        Print_MED(Rec, s, t, i, j - 1)
        # 打印插入操作
        print(f"插入'{t[j-1]}'")


# ------------------------------------------------------------------
# 主程序测试
# ------------------------------------------------------------------
if __name__ == "__main__":
    # 测试用例
    s = "ABCBDAB"  # 源字符串
    t = "BDCABA"   # 目标字符串
    
    # 计算最小编辑距离
    D, Rec = Minimum_Edit_Distance(s, t)
    
    # 打印DP表（调试用）
    print("最小编辑距离DP表:")
    for row in D:
        print(row)
    
    print(f"\n编辑距离: {D[len(s)][len(t)]}")
    
    # 获取字符串长度作为回溯起点
    i = len(s)
    j = len(t)
    
    # 打印编辑操作序列
    print(f"\n从'{s}'转换为'{t}'的编辑操作:")
    Print_MED(Rec, s, t, i, j)
    print("完成！")
```

### 钢条切割问题
- 问题背景：现在有一个长度是10的钢条，可以零成本将其切割为多段长度更小的钢条，不同长度的钢条价格不一样，怎么切割可以使得总收益最大
- 形式化定义：
    - 输入：
        - 钢条长度
        - 价格表 $p_i(1\leq l \leq n)$:表示长度为 $l$ 的钢条价格
    - 输出：
        - 求解一组切割方案 $T=<c_1,c_2,...c_m>$ ,令
        $$\max{\sum_{l=1}^{m}}{p_{c_l}}\quad\text{优化目标}$$
        $$s.t.\sum{l=1}^{m}c_l = n\quad\text{约束条件}$$

- 问题简述
    - 假设至多切割一次
        - 枚举所有的可能切割位置:
            - 不切: $p[10]$
            - 切割: $p[i]+p[10-i]$
        - 最大收益:
            - $max_{1\leq i \leq 9}\{p[i]+p[10-i],p[10]\}$


- 问题结构分析
    - 给出问题表示：
        - $c[j]$:切割长度为 $j$ 的钢条可以获得最大的总收益
    - 明确原始问题：
        - $C[n]$:切割长度为 $n$ 的钢条可以获得最大的总收益
- 递推关系建立
    - 分析最优子结构：
        - 对每个钢条长度 $j$：
        - $$C[j]=\max_{1\leq i\leq j-1}\{p[i]+C[j-i],p[j]\}$$

- 自底向上计算：
    - 依次求解问题
        - 初始化
            - $C[0]=0$,切割长度为0的钢条，总收益为0
        - 递推公式
            - $$C[j]=\max_{1\leq i\leq j-1}\{p[i]+C[j-i],p[j]\}$$
- 最优方案追踪：记录决策过程
    - 构造追踪数组 $rec[1..n]$
    - $rec[j]$:记录长度为 $j$ 钢条的最优切割方案

- 伪代码
<div align="center">
<img src="./RodCutting.svg" width="600" alt="钢条切割" />
</div> 

```python
def RodCutting(p, n):
    """
    钢条切割问题：给定价格表p，求长度为n的钢条的最大收益
    
    参数:
        p: 价格列表，p[i]表示长度为i的钢条的价格（p[0]不使用，i从1开始）
        n: 钢条的总长度
    
    返回:
        rec: 记录数组，rec[j]表示长度为j的钢条第一段应切割的长度
        C: DP数组，C[j]表示长度为j的钢条能获得的最大收益
    """
    # ------------------------------------------------------------------
    # 阶段1: 初始化DP数组和记录数组
    # ------------------------------------------------------------------
    # C[j] 表示长度为j的钢条能获得的最大收益
    # 长度为0时收益为0，所以C[0] = 0
    C = [0] * (n + 1)
    
    # rec[j] 记录达到最大收益C[j]时，第一段切割的长度
    # 初始值设为j（不切分，整体出售）
    rec = [0] * (n + 1)
    
    # ------------------------------------------------------------------
    # 阶段2: 动态规划求解（自底向上）
    # ------------------------------------------------------------------
    # 遍历所有可能的钢条长度j（从1到n）
    for j in range(1, n + 1):
        
        # 初始情况：不切分，整体出售长度为j的钢条
        q = p[j]  # 直接出售的收益
        rec[j] = j  # 记录第一段切割长度为j（不切分）
        
        # 遍历所有可能的第一段切割长度i（从1到j-1）
        # 尝试将长度为j的钢条切分为i和j-i两部分
        for i in range(1, j):
            
            # 如果切分后的收益更大，则更新最优解
            # p[i]是左半部分的收益，C[j-i]是右半部分的最大收益
            if q < p[i] + C[j - i]:
                q = p[i] + C[j - i]  # 更新最大收益
                rec[j] = i  # 记录第一段切割长度为i
        
        # 保存长度为j时的最大收益
        C[j] = q
    
    # ------------------------------------------------------------------
    # 阶段3: 返回结果
    # ------------------------------------------------------------------
    return rec, C


def Print_RodCutting(rec, n):
    """
    根据记录数组rec，打印长度为n的钢条的最优切割方案
    
    参数:
        rec: 记录数组，来自RodCutting函数
        n: 钢条的总长度
    """
    # ------------------------------------------------------------------
    # 阶段4: 回溯并打印切割方案
    # ------------------------------------------------------------------
    # 当还有剩余长度时继续切割
    parts = []  # 存储切割出的每一段长度
    while n > 0:
        # rec[n]给出当前钢条第一段应切割的长度
        parts.append(rec[n])
        n = n - rec[n]  # 剩余长度
    
    # 打印详细的切割方案
    print("切割方案:", " + ".join(map(str, parts)))
    return parts


# ------------------------------------------------------------------
# 主程序测试
# ------------------------------------------------------------------
if __name__ == "__main__":
    # 价格表：p[i]表示长度为i的钢条的价格
    # p[0]不使用，索引从1开始对应钢条长度
    p = [0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 24]  # 长度为0到10的价格
    
    # 钢条总长度
    n = 10
    
    # 计算最优解
    rec, C = RodCutting(p, n)
    
    # 打印结果
    print("=" * 50)
    print(f"钢条长度: {n}")
    print(f"价格表: {p[1:]}")  # 跳过p[0]
    print("=" * 50)
    print("DP数组C（最大收益）:", C)
    print("记录数组rec（第一段切多长）:", rec)
    print("=" * 50)
    print("最优切割方案:")
    parts = Print_RodCutting(rec, n)
    
    # 验证收益
    total_revenue = sum(p[length] for length in parts)
    print(f"总收益: {total_revenue}（验证C[{n}] = {C[n]}）")
```

### 矩阵链乘法问题

- 问题背景：
    - 基本知识：两个矩阵相乘，矩阵大小是 $p\times q,q\times r$
    - 矩阵乘法的时间复杂度：
        - 计算1个数字：需要 $q$ 次标量乘法
        - 共计 $p\times r$ 个数， $\Theta(pqr)$
    - 三个矩阵相乘：
        - 矩阵乘法的结合律：$(UV)W=U(VW)$
        - 新问题：矩阵乘法结合的顺序
    - n个矩阵相乘
        - 有一系列矩阵按照顺序排序
        - 每个矩阵的行数=前一个矩阵列数
        - n个矩阵相乘也称为矩阵乘法

- 矩阵乘法问题
    - 输入：
        - $n$ 个矩阵组成的矩阵链 $U_{1..n}=<U_1,U_2,..,U_n>$
        - 矩阵链 $U_{1..n}$ 对应的维度数分别是 $p_0,p_1,...p_n$ , $U_i$ 的维度数是 $p_{i-1}\times p_i$
    - 输出：
        - 找到一种加括号的方式，以确定矩阵乘法的计算顺序，使得最小化矩阵链标量乘法的次数
- 问题结构分析
    - 给出问题表示
        - $D[i,j]$：计算矩阵链$U_{i,..j}$ 所需要的标量的乘法的最小数目
    - 明确原始问题
        - $D[1,n]$：计算矩阵链 $U_{1,..n}$ 所需要的乘法的最小次数

- 递推关系建立：分析最优子结构
    - 对矩阵链 $U_{i,..j}$ , 求解$D[i,j]$ $$U_i,...U_k,U_{k+1}..U_j$$
    - $D[i,j]=D[i,k]+D[k+1,j]+p_{i-1}p_k p_k$
    - 对每个位置 $k$ ,$ i\leq k \leq j$
        - $D[i,j]=D[i,k]+D[k+1,j]+p_{i-1}p_k p_k$
    - 枚举所有的 $k$ ,得到递推式 
        - $D[i,j]=\min_{i\leq k <j>}(D[i,k]+D[k+1,j]+p_{i-1}p_k p_k)$

- 自底向上计算：确定计算顺序
    - 初始化
        - $i=j$时，矩阵链只有一个矩阵，乘法次数是0
    - 递推公式
        - $D[i,j]=\min_{i\leq k <j>}(D[i,k]+D[k+1,j]+p_{i-1}p_k p_k)$
    

- 最优方案追踪：输出最优方案
    - 根据追踪数组，递归输出方案

- 伪代码

<div align="center">
<img src="./MCM.svg" width="600" alt="矩阵乘法" />
</div> 

```python
import math

def Matrix_Chain_Order(p):
    """
    矩阵链乘法最优计算顺序（求最小标量乘法次数）
    
    参数:
        p: 数组，p[i-1]×p[i] 表示第i个矩阵的维度
           例如: p = [2,3,7,9,5,2,4] 表示6个矩阵：
           M1:2×3, M2:3×7, M3:7×9, M4:9×5, M5:5×2, M6:2×4
    
    返回:
        m: DP表，m[i][j]表示计算矩阵Mi到Mj的最小乘法次数
        s: 分割点表，s[i][j]记录最优分割位置k
    """
    n = len(p) - 1  # 矩阵个数 = p的长度 - 1
    
    # ------------------------------------------------------------------
    # 阶段1: 初始化DP表
    # ------------------------------------------------------------------
    # m[i][j] 表示第i个矩阵到第j个矩阵（1-indexed）的最小乘法次数
    m = [[0] * (n + 1) for _ in range(n + 1)]
    
    # s[i][j] 记录达到最小值时的分割点k，即 Mi..Mj = (Mi..Mk) × (Mk+1..Mj)
    s = [[0] * (n + 1) for _ in range(n + 1)]
    
    # ------------------------------------------------------------------
    # 阶段2: 动态规划（按链长度递增计算）
    # ------------------------------------------------------------------
    # l 表示矩阵链的长度（包含多少个矩阵）
    for l in range(2, n + 1):  # l = 2,3,...,n
        
        # i 表示链的起始矩阵编号（1-indexed）
        for i in range(1, n - l + 2):
            
            # j 表示链的结束矩阵编号
            j = i + l - 1
            
            # 初始化m[i][j]为无穷大
            m[i][j] = math.inf
            
            # 遍历所有可能的分割点k
            for k in range(i, j):
                
                # 计算分割点k的代价
                q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]
                
                # 如果此分割点的代价更小，更新最优解
                if q < m[i][j]:
                    m[i][j] = q
                    s[i][j] = k
    
    # ------------------------------------------------------------------
    # 阶段3: 返回结果
    # ------------------------------------------------------------------
    return m, s


def Print_Optimal_Parens(s, i, j):
    """
    根据分割点表s，打印矩阵链的最优括号化方案
    
    参数:
        s: 分割点表（来自Matrix_Chain_Order函数）
        i: 起始矩阵编号（1-indexed）
        j: 结束矩阵编号（1-indexed）
    """
    if i == j:
        print(f"A{i}", end='')
    else:
        print("(", end='')
        k = s[i][j]
        Print_Optimal_Parens(s, i, k)
        Print_Optimal_Parens(s, k + 1, j)
        print(")", end='')


# ------------------------------------------------------------------
# 主程序测试
# ------------------------------------------------------------------
if __name__ == "__main__":
    p = [2, 3, 7, 9, 5, 2, 4]
    
    m, s = Matrix_Chain_Order(p)
    
    n = len(p) - 1
    print(f"矩阵个数: {n}")
    
    print("\n最小乘法次数表 m:")
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            if j >= i:
                print(f"{m[i][j]:4d}", end='')
            else:
                print("    ", end='')
        print()
    
    print("\n最优括号化方案:")
    Print_Optimal_Parens(s, 1, n)
    print(f"\n\n最小标量乘法次数: {m[1][n]}")
```