# 归并排序


## 引入：杠铃增重问题

背景：每位参赛运动员需要提交三次举重量，为了方便杠铃拆卸，需要对所有的试举重量进行递增排序

快速合并：比较两个有序数组当前的最小元素，将最小者合入到新数组

## 归并排序

- 分解原问题：将数组 $A[1,n]$ 分解为 $A[1,\lfloor \frac{n}{2} \rfloor]$ 和 $A[\lfloor \frac{n}{2} \rfloor,n]$ 两个排序子问题
- 解决子问题：递归求解子问题，得到两个有序的子数组
- 合并问题解：将两个有序子数组合并成一个完整的有序数组

<div align="center">
<img src="./归并排序.svg" width="600" alt="归并排序" />
</div>

```python
# 归并排序代码
from typing import List

def merge_sort(arr: List[int], left: int, right: int) -> None:
    """
    对数组 arr 的 [left, right] 区间进行原地归并排序。
    
    参数:
        arr: 待排序的列表（原地修改）
        left: 排序区间的左边界索引（包含）
        right: 排序区间的右边界索引（包含）
    """
    # 递归终止条件：区间长度为0或1时已经有序
    if left >= right:
        return
    
    # 计算中间点，将区间分为左右两个子区间
    mid = (left + right) // 2
    
    # 递归排序左半部分 [left, mid]
    merge_sort(arr, left, mid)
    
    # 递归排序右半部分 [mid+1, right]
    merge_sort(arr, mid + 1, right)
    
    # 合并两个已排序的子区间
    merge(arr, left, mid, right)


def merge(arr: List[int], left: int, mid: int, right: int) -> None:
    """
    合并两个已排序的子数组 arr[left..mid] 和 arr[mid+1..right]。
    
    参数:
        arr: 待合并的列表（原地修改）
        left: 左子数组的起始索引
        mid: 左子数组的结束索引
        right: 右子数组的结束索引
    """
    # 创建临时数组，复制待合并区间的元素（避免被覆盖）
    temp = arr[left:right + 1].copy()
    
    # 初始化三个指针：
    # i: 遍历左子数组 [left, mid]
    # j: 遍历右子数组 [mid+1, right]
    # k: 临时数组中的偏移量（从0开始）
    i, j, k = left, mid + 1, 0
    
    # 比较两个子数组的元素，按升序合并到原数组
    # 使用 < 保证排序稳定性（相等时优先取左子数组的元素）
    while i <= mid and j <= right:
        if temp[i - left] < temp[j - left]:
            arr[k + left] = temp[i - left]
            i += 1
        else:
            arr[k + left] = temp[j - left]
            j += 1
        k += 1
    
    # 复制左子数组剩余的元素（如果有）
    while i <= mid:
        arr[k + left] = temp[i - left]
        i += 1
        k += 1
    
    # 复制右子数组剩余的元素（如果有）
    while j <= right:
        arr[k + left] = temp[j - left]
        j += 1
        k += 1


if __name__ == "__main__":
    # 测试用例
    arr = [4, 1, 2, 5, 6, 3]
    print(f"排序前: {arr}")
    
    merge_sort(arr, 0, len(arr) - 1)
    
    print(f"排序后: {arr}")
```


## 复杂度分析

$$
T(n) = \begin{cases}
2T(n/2) + O(n), & \text{if } n > 1 \\
O(1), & \text{if } n = 1
\end{cases}
$$


- 递归树法：用树的形式表示抽象递归

<div align="center">
<img src="./递归树法.svg" width="600" alt="递归树法" />
</div>

- 代入法：

$$
T(n) = \begin{cases}
T(n/4) + T(3n/4) + O(n), & \text{if } n > 4 \\
O(1), & \text{if } n <4
\end{cases}
$$

猜测： $T(n)=\Theta(n\log n)$ ,即 $\exists c_1,c_2,n_0>0$  ,使得 $\forall n\geq n_0,c_1g(n)\leq T(n)\leq c_2g(n)$ 

使用数学归纳法证明（不重要）



- 主定理法：（重要）

观察形如 $T(n)=aT(\frac{n}{b})+f(n)$  

$$
T(n) = 
\begin{cases}
O\bigl(f(n)\bigr)          & \text{if } f(n) = \Omega\!\bigl(n^{\log_b a + \epsilon}\bigr) \\[6pt]
O\bigl(n^{\log_b a}\log n\bigr) & \text{if } f(n) = \Theta\!\bigl(n^{\log_b a}\bigr) \\[6pt]
O\bigl(n^{\log_b a}\bigr)  & \text{if } f(n) = O\!\bigl(n^{\log_b a - \epsilon}\bigr)
\end{cases}
$$

比较根节点代价 $f(n)$ 与叶节点代价之和 $n^{\log_b a}$ 


<div align="center">
<img src="./主定理.svg" width="600" alt="主定理" />
</div>


- 主定理简化（**重要**）

对形如  $T(n) = aT(n/b) + n^k$  的递归式：

$$
T(n) = 
\begin{cases}
O\bigl(n^k\bigr)            & \text{if } k > \log_b a \\[6pt]
O\bigl(n^k \log n\bigr)     & \text{if } k = \log_b a \\[6pt]
O\bigl(n^{\log_b a}\bigr)   & \text{if } k < \log_b a
\end{cases}
$$

- 主定理扩展

对形如  $T(n) = aT(n/b) + f(n)$  的递归式：
$$
T(n) = \begin{cases}
O(f(n)) & \text{if } f(n) = \Omega(n^{\log_b a + \epsilon}) \text{（情况1）} \\
O(n^{\log_b a} \log^{k+1} n) & \text{if } f(n) = \Theta(n^{\log_b a} \log^k n), \, k \geq 0 \text{（情况2）} \\
O(n^{\log_b a}) & \text{if } f(n) = O(n^{\log_b a - \epsilon}) \text{（情况3）}
\end{cases}
$$




对于情况2，情况2的扩展

$$
T(n) = \begin{cases}
O\bigl(n^{\log_b a} \log^{k+1} n\bigr) & \text{if } k > -1 \\[6pt]
O\bigl(n^{\log_b a} \log\log n\bigr)   & \text{if } k = -1 \\[6pt]
O\bigl(n^{\log_b a}\bigr)              & \text{if } k < -1
\end{cases}
$$

<div align="center">
<img src="./主定理扩展.svg" width="600" alt="主定理扩展" />
</div>

## 主定理例子
例子1：

 $T(n)=5T(n/2)+n^3$ 

**参数识别**：
-  $a = 5, b = 2, k = 3$ 
-  $\log_b a = \log_2 5$ 

**情况判断**：
$$ k = 3 > \log_2 5 $$

属于 **情况①**，因此：
$$ T(n) = O(n^k) = O(n^3) 
$$



例子2：

 $T(n)=4T(n/4)+n^{1/2}$  

**参数识别**：
-  $a = 4, b = 4, k = \frac{1}{2}$  
-  $\log_b a = \log_4 4 = 1$  

**情况判断**：
$$ k = \frac{1}{2} < \log_4 a = 1 $$

属于 **情况③**，因此：
$$ T(n) = O(n^{\log_b a}) = O(n) $$

例子3：

 $T(n)=3T(n/4)+n\log n$ 


**参数识别**：
-  $a = 3, b = 4$ 
-  $\log_b a = \log_4 3 < 1$ 

**正则条件验证**：
存在  $\varepsilon > 0$  使得  $\log_4 3 + \varepsilon < 1$ ，故：
$$ f(n) = n\log n = \Omega(n^{\log_b a + \varepsilon}) $$

且  $af(n/b) = 3 \cdot \frac{n}{4}\log\frac{n}{4} < cf(n)$  对某个  $c < 1$  成立

属于 **情况①**，因此：
$$ T(n) = O(f(n)) = O(n\log n) $$

例子4：

 $T(n)=2T(n/2)+n\log n$ 

**参数识别**：
-  $a = 2, b = 2, k = 1$ 
-  $\log_b a = \log_2 2 = 1$ 

**情况分析**：
-  $f(n) = n\log n$  与  $n^{\log_b a} = n$  比较
- 然而对任意  $\varepsilon > 0$ ， $\log n$  渐进小于  n^\varepsilon$ 
- 不存在  $\varepsilon > 0$  使  $f(n) = \Omega(n^{1+\varepsilon})$ 

**结论**：该情况落入情况①和②之间，**不能使用主定理**，需用递归树法求解，结果为  $T(n) = O(n\log^2 n)$ 


# 经典问题

## 最大子数组问题I

### 问题描述
- 名称：MaxContinuousSubarray, MCS
- 问题背景：子数组是原数组中的一段序列
- 输入：给定一个数字组 $X[1..n]$ ,对于任意一对数组下标为 $l,r(l\leq r)$ 的非空子数组
$$S(l,r)=\sum_{i=l}^{r}X[i]$$
- 输出：求出 $S(l,r)$ 的最大值，记为 $S_{max}$ 


### 解决思路

- 蛮力枚举：数组 $X[1..n]$ ,其所有的下标 $l,r(l\leq r)$ 组合分分为几种情况

  - 当  $l=r$  ，一共有n种组合
  - 当  $l<r$  ，一共有 $C_n^2$ 种组合

<div align="center">
<img src="./mcs-1.svg" width="600" alt="mcs-1" />
</div>

```python
import math
from typing import List

def MaxSubArray(arr: List[int], left: int, right: int) -> int:
    """
    使用分治法找出数组 arr[left..right] 中的最大子数组和。
    
    算法思路：
    1. 将数组分为左右两半
    2. 最大子数组和要么完全在左半部分，要么完全在右半部分，
       要么跨越中间点（同时包含左右两部分）
    3. 递归求解左右两部分，单独处理跨越情况，最后取三者最大值
    
    参数:
        arr: 输入数组
        left: 左边界索引（包含）
        right: 右边界索引（包含）
    
    返回:
        该区间内的最大子数组和（int 类型）
    """
    # 基本情况：当区间只有一个元素时，直接返回该元素
    if left == right:
        return arr[left]
    
    # 计算中间索引，将数组分为左右两个子区间
    mid = (left + right) // 2
    
    # 递归计算左半部分 [left, mid] 的最大子数组和
    S1 = MaxSubArray(arr, left, mid)
    
    # 递归计算右半部分 [mid+1, right] 的最大子数组和
    S2 = MaxSubArray(arr, mid + 1, right)
    
    # 计算跨越中间点的最大子数组和（必须同时包含左右两部分的元素）
    S3 = CrossingSubArray(arr, left, mid, right)
    
    # 返回三种情况中的最大值
    return max(S1, S2, S3)


def CrossingSubArray(arr: List[int], left: int, mid: int, right: int) -> int:
    """
    计算跨越中间点的最大子数组和。
    该子数组必须包含 arr[mid] 和 arr[mid+1]。
    
    算法思路：
    1. 从中间点向左扫描，找出包含 arr[mid] 的最大子数组和
    2. 从中间点+1向右扫描，找出包含 arr[mid+1] 的最大子数组和
    3. 返回左右两部分之和
    
    参数:
        arr: 输入数组
        left: 左边界索引（包含）
        mid: 中间索引
        right: 右边界索引（包含）
    
    返回:
        跨越中间点的最大子数组和
    """
    # 初始化左半部分的最大和为负无穷，用于追踪最大值
    left_max = -math.inf
    # 初始化左半部分的当前和为0
    left_sum = 0
    
    # 从中间点向左遍历，找出包含 arr[mid] 的最大子数组和
    # range(mid, left-1, -1) 确保包含 left 到 mid 的所有索引
    for i in range(mid, left - 1, -1):
        left_sum += arr[i]
        left_max = max(left_sum, left_max)
    
    # 初始化右半部分的最大和为负无穷
    right_max = -math.inf
    # 初始化右半部分的当前和为0
    right_sum = 0
    
    # 从中间点+1向右遍历，找出包含 arr[mid+1] 的最大子数组和
    # range(mid+1, right+1) 确保包含 mid+1 到 right 的所有索引
    for j in range(mid + 1, right + 1):
        right_sum += arr[j]
        right_max = max(right_sum, right_max)
    
    # 返回左右两部分之和，即跨越中间点的最大子数组和
    return left_max + right_max


# 测试代码
if __name__ == "__main__":
    # 测试用例：最大子数组是 [1, 8, -4, 5]，和为 10
    arr = [-1, -3, -5, 1, 8, -4, 5]
    print(f"输入数组: {arr}")
    
    max_sum = MaxSubArray(arr, 0, len(arr) - 1)
    print(f"最大子数组和: {max_sum}")
    
    # 验证正确性
    assert max_sum == 10, f"结果不正确，期望 10，实际 {max_sum}"
    print("✓ 测试通过")
```
- 优化枚举：利用之前已经计算的数据
 $S(l,r)=\sum_{i=l}^{r}X[i]=S(l,r-1)+X[r]$ 


<div align="center">
<img src="./mcs-2.svg" width="600" alt="mcs-2" />
</div>

- 分而治之

    - 将数组 $X[1..n]$ 分为 $X[1..n/2]$ 和 $X[n/2+1..n]$ 
    - 递归求解子问题：
        -  $S_1$ :数组 $X[1..n/2]$ 的最大子数组
        -  $S_2$ :数组 $X[n/2+1...n]$ 的最大子数组
    - 合并子问题：得到  $S_{max}$ 
        -  $S_3$ :跨中点的最大子数组
        - 数组 $X$ 的最大子数组之和 $S_{max}=\max\{S_1,S_2,S_3\}$  

    - 求解 $S_3$ 
        - 记 $mid=n/2$ 
        -  $S_3$ 分为左右两部分, $S_3=left+right$ 
            - left:以 $X[mid]$ 为结尾的最大子数组之和
            - right:以 $X[mid+1]$ 为开头的最大子数组之和
            - 分别求出left，right便可求出 $S_3$  


### 伪代码

<div align="center">
<img src="./mcs-3.svg" width="600" alt="mcs-3" />
</div>

## 逆序对计数问题

### 问题描述
- 名称：逆序对计数问题Counting Inversions(CI)
- 输入：长度为 n 的数组 $A[1..n]$ 
- 输出：数组 $A[1..n]$ 逆序对的总数，
$$\sum_{1\leq i< j \leq n}X_{i,j}$$

$$
X_{i,j} = \begin{cases}
1 &  A[i]>A[j] \\
0 &  A[i]\leq A[j]
\end{cases}
$$

### 解决思路

- 蛮力枚举：对于数组的每个元素 $A[i]$ ,枚举 j(j>i) ,并统计逆序对数目

<div align="center">
<img src="./CI-1.svg" width="600" alt="CI-1" />
</div>

- 分而治之：

    - 将数组 $A[1..n]$ 分为 $A[1..n/2]$ 和 $A[n/2+1..n]$ 
    - 递归求解子问题：
        -  $S_1$ :数组 $A[1..n/2]$ 的逆序对数目
        -  $S_2$ :数组 $A[n/2+1...n]$ 的逆序对数目
    - 合并 $A[1..n/2]$ 和 $A[n/2+1...n]$ 的解
        -  $S_3$ :跨越子数组的逆序对数目
        -  $S=S_1+S_2+S_3$ 

    - 策略1，直接求解
        - 求解方法：对每个 $A[j]\in A[m+1..n]$ ,枚举 $A[i]\in A[1..m]$ 并统计逆序对数目，导致求解 $S_3$ 的算法运行时间是 $O(n^2)$ ,分而治之框架的算法运行时间是 $T(n)=2\cdot T(n/2)+O(n^2)$ 
        - 致因分析：运行时间受制于跨越子数组的逆序对计数方法，数组的有序性通常有助于提高算法的运行时间

    - 策略2，排序求解
        - 求解方法：
            - 1.分别对每个数组 $A[1..m]$ 和 $A[m+1..n]$ 进行排序
            - 2.对于每个 $A[j]\in A[m+1..n]$ ，采用二分查找为其在 $A[1..m]$ 中的定位
            - 3. $A[j]$ 在 $A[1..m]$ 定位点右侧的元素均可以与 $A[j]$ 构成逆序对
            - 4.求解 $S_3$ 的算法运行时间 $O(n\log n)$ 
            - 5.分而治之框架的算法运行时间： $T(n)=2T(n/2)+O(n\log n)$ 
        - 致因分析：未将排序过程融入整个算法框架
    - 策略3，归并求解
        - 求解方法：
            - 1.从左到右扫描有序子数组： $A[i]\in A[1..m]$ , $A[j]\in A[m+1..n]$ 
                - 如果 $A[i]>A[j]$ ,统计逆序对， $j$ 右移
                - 如果 $A[i]\leq A[j]$ , $i$ 右移
            - 2.利用归并排序框架保证合并之后数组的有序性

<div align="center">
<img src="./CI-2.svg" width="600" alt="CI-2" />
</div>

<div align="center">
<img src="./CI-3.svg" width="600" alt="CI-3" />
</div>

<div align="center">
<img src="./CI-4.svg" width="600" alt="CI-4" />
</div>

### 伪代码

- 归并排序伪代码
<div align="center">
<img src="./CI-5.svg" width="600" alt="CI-5" />
</div>

```python
from typing import List

def MergeCount(arr: List[int], left: int, right: int) -> int:
    """
    使用归并排序统计数组 arr[left..right] 中的逆序对总数。
    
    逆序对定义：对于数组中的两个元素 arr[i] 和 arr[j]，如果 i < j 且 arr[i] > arr[j]，
    则称 (i, j) 构成一个逆序对。
    
    算法思路（分治法）：
    1. 将数组分为左右两半
    2. 逆序对总数 = 左半部分的逆序对 + 右半部分的逆序对 + 跨越左右两部分的逆序对
    3. 递归计算左右两部分，在合并过程中统计跨越的逆序对
    
    参数:
        arr: 待统计的数组（会被修改成有序状态以辅助统计）
        left: 左边界索引（包含）
        right: 右边界索引（包含）
    
    返回:
        该区间内的逆序对总数（int 类型）
    """
    # 基本情况：区间长度为0或1时，不存在逆序对
    if left >= right:
        return 0
    
    # 计算中间索引，将数组分为左右两个子区间
    mid = (left + right) // 2
    
    # 递归计算左半部分 [left, mid] 的逆序对数量
    num_left = MergeCount(arr, left, mid)
    
    # 递归计算右半部分 [mid+1, right] 的逆序对数量
    num_right = MergeCount(arr, mid + 1, right)
    
    # 在合并过程中统计跨越左右两部分的逆序对数量
    num = CountInverse(arr, left, mid, right)
    
    # 返回三部分逆序对的总和
    return num_left + num_right + num


def CountInverse(arr: List[int], left: int, mid: int, right: int) -> int:
    """
    在合并两个已排序的子数组时，统计跨越左右两部分的逆序对数量。
    
    逆序对产生条件：
    当左子数组的当前元素 arr[i] > 右子数组的当前元素 arr[j] 时，
    左子数组中从 i 到 mid 的所有元素都大于 arr[j]，因此都与 arr[j] 构成逆序对。
    
    参数:
        arr: 输入数组
        left: 左子数组的起始索引
        mid: 左子数组的结束索引
        right: 右子数组的结束索引
    
    返回:
        跨越中间点的逆序对数量
    """
    # 创建临时数组，保存待合并区间的原始数据（避免被覆盖）
    temp = arr[left:right + 1].copy()
    
    # 初始化指针：
    # i: 遍历左子数组 [left, mid]
    # j: 遍历右子数组 [mid+1, right]
    # k: 在原数组中的写入位置
    i, j, k = left, mid + 1, left
    
    # count: 记录跨越逆序对的数量
    count = 0
    
    # 比较并合并两个子数组，同时统计逆序对
    while i <= mid and j <= right:
        if temp[i - left] <= temp[j - left]:
            # 左元素 <= 右元素，不构成逆序对，直接放入
            arr[k] = temp[i - left]
            i += 1
        else:
            # 左元素 > 右元素，构成逆序对
            # 左子数组中从 i 到 mid 的所有元素都大于当前右元素
            arr[k] = temp[j - left]
            j += 1
            # 统计新增的逆序对数量：mid - i + 1
            count += (mid - i + 1)
        k += 1
    
    # 复制左子数组剩余的元素（如果有）
    while i <= mid:
        arr[k] = temp[i - left]  
        k += 1
        i += 1
    
    # 复制右子数组剩余的元素（如果有）
    while j <= right:
        arr[k] = temp[j - left]  
        k += 1
        j += 1
    
    # 返回本次合并过程中统计的跨越逆序对数量
    return count


# 测试代码
if __name__ == "__main__":
    # 测试用例：逆序对包括 (2,1), (6,5)，共 2 个
    arr = [2, 1, 3, 4, 6, 5]
    print(f"输入数组: {arr}")
    
    # 统计逆序对数量（arr会被排序）
    inverse_count = MergeCount(arr, 0, len(arr) - 1)
    print(f"逆序对总数: {inverse_count}")
    print(f"排序后数组: {arr}")
    
    # 验证正确性
    assert inverse_count == 2, f"结果不正确，期望 2，实际 {inverse_count}"
    print("✓ 测试通过")
```

```
分而治之的策略的关键是什么？

答案：合理设计合并求解算法
```

## 多项式乘法问题

- 问题背景：
    -  $A(x)=1+2x+3x^2$ 
    -  $B(x)=3+2x+2x^2$ 
    -  $C(x)=A(x)B(x)=3+8x+15x^2+10x^3+6x^4$  
- 数据表示：
    -  $A(x)$ 的系数向量： $A=(1,2,3)$ 
    -  $B(x)$ 的系数向量： $B=(3,2,2)$ 
    -  $C(x)$ 的系数向量： $C=(3,8,15,10,6)$ 
- 性能指标：
    - 标量的乘法和加法操作

- 名称：Polynomial Multiplication problem
- 输入：两个多项式
    -  $A(x)=a_0+a_1 x+...a_n x^n$ 
    -  $B(x)=b_0+b_1 x+...b_n x^n$ 
- 输出：两个多项式的乘积
    -  $C(x)=A(x)B(x)=\sum_{k=0}^{n+m}c_k x^k$ 
    - 其中 $c_k=\sum_{0\leq i\leq n,0\leq j\leq m,i+j=k}a_ib_j,0\leq k\leq m+n$ 


### 问题思路

- 普通分治
    - 具体做法：四次递归，分别求解 $A_0(x)B_0(x),A_0(x)B_1(x),A_1(x)B_0(x),A_1(x)B_1(x)$ 
    - 合并问题解： $A(x)B(x)=A_0(x)B_0(x)+A_1(x)B_0(x)x^{n/2}+A_0(x)B_1(x)x^{n/2}+A_1(x)B_1(x)x^{n}$ 
- 合并同类项
    -  $A(x)B(x)=A_0(x)B_0(x)+[A_1(x)B_0(x)+A_0(x)B_1(x)]x^{n/2}+A_1(x)B_1(x)x^{n}$  
    - 三次递归： $Y=(A_0+A_1)(B_0+B_1) ， U=A_0B_0 ， Z=A_1B_1 ， A_1B_0+A_0B_1=Y-U-Z$  


```python
from typing import List

def poly_multiply(a: List[int], b: List[int]) -> List[int]:
    """
    使用分治算法（Karatsuba）计算两个多项式的乘积
    
    多项式表示：数组索引i对应x^i的系数
    例如：[1,2,3] 表示 1 + 2x + 3x²
    
    参数:
        a: 多项式A的系数数组（长度 ≥ 1）
        b: 多项式B的系数数组（长度 ≥ 1）
    
    返回:
        乘积多项式的系数数组
    
    示例:
        (1 + 2x) * (3 + 4x) = 3 + 10x + 8x²
        [1,2] * [3,4] = [3,10,8]
    """
    # 基础情况：长度为1时直接相乘
    n = len(a)
    m = len(b)
    
    if n == 1 and m == 1:
        return [a[0] * b[0]]
    
    # 使两个数组长度相同（补零）
    max_len = max(n, m)
    a = a + [0] * (max_len - n)
    b = b + [0] * (max_len - m)
    
   
    
    # 分割点
    k = max_len // 2
    
    # 分割多项式为高低两部分
    a0 = a[:k]          # 低次项
    a1 = a[k:]          # 高次项
    b0 = b[:k]
    b1 = b[k:]
    
    # Karatsuba算法：3次递归乘法
    U = poly_multiply(a0, b0)          # U = a0 * b0
    Z = poly_multiply(a1, b1)          # Z = a1 * b1
    
    # Y = (a0 + a1) * (b0 + b1)
    a01 = add_arrays(a0, a1)
    b01 = add_arrays(b0, b1)
    Y = poly_multiply(a01, b01)
    
    # 计算中间项：Y - U - Z
    middle = subtract_arrays(subtract_arrays(Y, U), Z)
    
    # 合并结果：U + middle*x^k + Z*x^(2k)
    result = [0] * (n + m - 1)  # 结果最大长度为n+m-1
    
    # 添加U（低次项）
    for i in range(len(U)):
        result[i] += U[i]
    
    # 添加middle（中次项，偏移k位）
    for i in range(len(middle)):
        result[i + k] += middle[i]
    
    # 添加Z（高次项，偏移2k位）
    for i in range(len(Z)):
        result[i + 2 * k] += Z[i]
    
    return result




def add_arrays(a: List[int], b: List[int]) -> List[int]:
    """数组加法（对应系数相加）"""
    n, m = len(a), len(b)
    max_len = max(n, m)
    result = [0] * max_len
    
    for i in range(n):
        result[i] += a[i]
    
    for i in range(m):
        result[i] += b[i]
    
    return result


def subtract_arrays(a: List[int], b: List[int]) -> List[int]:
    """数组减法（对应系数相减）"""
    n, m = len(a), len(b)
    max_len = max(n, m)
    result = [0] * max_len
    
    for i in range(n):
        result[i] += a[i]
    
    for i in range(m):
        result[i] -= b[i]
    
    return result


# ============= 测试代码 =============
if __name__ == "__main__":
    # 示例1: (1 + 2x) * (3 + 4x) = 3 + 10x + 8x²
    a1 = [1, 2]      # 1 + 2x
    b1 = [3, 4]      # 3 + 4x
    result1 = poly_multiply(a1, b1)
    print(f"{a1} × {b1} = {result1}")

    # 示例2: [1,2,3] × [3,2,2] = [3,8,13,10,6]
    a2 = [1, 2, 3]   # 1 + 2x + 3x²
    b2 = [3, 2, 2]   # 3 + 2x + 2x²
    result2 = poly_multiply(a2, b2)
    print(f"{a2} × {b2} = {result2}")
 

```
# 快速排序

## 基本思想

- 快速排序：侧重分解，简化合并

- 算法简介：
    - 选取固定位置元素 $x$ ,(如尾部元素)
    - 维护两个部分的右端点变量$i,j$
    - 考察数组元素 $A[j]$ ,只和主元比较
        - 若$A[j]\leq x$,则交换 $A[j]$ , $A[i+1]$ , $i,j$ 右移
        - 若$A[j]> x$ ,则 $j$ 右移
    - 把主元放在中间作为分界线
## 伪代码

- 快速排序

<div align="center">
<img src="./快速排序.svg" width="600" alt="快速排序" />
</div>

为了防止数组划分的时候固定选取位置主元，可以针对性构造最差的情况，在Partition中使用随机选取主元


```python
from typing import List

def quickSort(arr: List[int], p: int, r: int) -> None:
    """
    快速排序主函数（原地排序）
    
    参数:
        arr: 待排序的数组（原地修改）
        p:   排序区间的左边界索引（包含）
        r:   排序区间的右边界索引（包含）
    
    算法思路：
    1. 如果区间有效（p < r），选择基准元素
    2. 通过partition函数将数组划分为两部分
    3. 递归排序左半部分 [p, q-1]
    4. 递归排序右半部分 [q+1, r]
    """
    if p < r:
        # 划分数组，q是基准元素的最终位置
        q = partition(arr, p, r)
        
        # 递归排序左半部分（所有小于基准的元素）
        quickSort(arr, p, q - 1)
        
        # 递归排序右半部分（所有大于基准的元素）
        quickSort(arr, q + 1, r)
        
  

def partition(arr: List[int], p: int, r: int) -> int:
    """
    分区函数（Lomuto方案）
    
    功能：
    选择arr[r]作为基准（pivot），重新排列数组，
    使得所有小于基准的元素都在其左侧，大于基准的在右侧
    
    参数:
        arr: 待分区的数组（原地修改）
        p:   分区区间的左边界索引（包含）
        r:   分区区间的右边界索引（包含）
    
    返回:
        基准元素的最终索引位置
    """
    # 选择最后一个元素作为基准
    x = arr[r]
    
    # i指向小于基准区域的最后一个元素
    i = p - 1
    
    # j遍历从p到r-1的所有元素
    for j in range(p, r):
        # 如果当前元素小于基准
        if arr[j] < x:
            # 将其与i+1位置的元素交换，扩展到"小于区域"
            arr[j], arr[i + 1] = arr[i + 1], arr[j]
            i += 1  # "小于区域"扩大
    
    # 循环结束后，arr[p..i]都小于基准，arr[i+1..r-1]都大于等于基准
    
    # 将基准元素放到正确位置（i+1）
    arr[i + 1], arr[r] = arr[r], arr[i + 1]
    
    # 返回基准的最终位置
    q = i + 1
    return q


# ============= 测试代码 =============
if __name__ == "__main__":
    # 测试用例
    arr = [4, 1, 2, 5, 6, 3]
    print(f"排序前: {arr}")
    
    quickSort(arr, 0, len(arr) - 1)
    
    print(f"排序后: {arr}")
    
```

- 随机快速排序

<div align="center">
<img src="./随机快速排序.svg" width="600" alt="随机快速排序" />
</div>

```python
import random
from typing import List

def random_quickSort(arr: List[int], p: int, r: int) -> None:
    """
    随机化快速排序主函数（原地排序）
    
    算法特点：
    1. 通过随机选择基准元素，避免最坏情况O(n²)
    2. 期望时间复杂度始终为O(n log n)
    3. 原地排序，空间复杂度O(log n)
    
    参数:
        arr: 待排序数组（原地修改）
        p:   排序区间左边界（包含）
        r:   排序区间右边界（包含）
    """
    if p < r:
        # 随机划分，返回基准元素的最终位置
        q = random_partition(arr, p, r)
        
        # 递归排序左半部分 [p, q-1]
        random_quickSort(arr, p, q - 1)
        
        # 递归排序右半部分 [q+1, r]
        random_quickSort(arr, q + 1, r)
        

def random_partition(arr: List[int], p: int, r: int) -> int:
    """
    随机化分区函数（Lomuto方案）
    
    关键步骤：
    1. 随机选择 [p, r] 范围内的一个元素作为基准
    2. 将其与 arr[r] 交换（移到末尾）
    3. 执行标准Lomuto分区
    
    参数:
        arr: 待分区数组（原地修改）
        p:   分区左边界（包含）
        r:   分区右边界（包含）
    
    返回:
        基准元素的最终索引
    """
    # 随机选择基准元素索引（在[p, r]范围内等概率选择）
    s = random.randrange(p, r + 1)
    
    # 将基准交换到数组末尾（r位置）
    arr[s], arr[r] = arr[r], arr[s]
    
    # 以下为标准Lomuto分区逻辑（与之前相同）
    x = arr[r]          # 基准值
    i = p - 1           # "小于区域"的边界
    
    # 遍历 [p, r-1]，将小于基准的元素移到左侧
    for j in range(p, r):
        if arr[j] < x:
            # 扩展"小于区域"
            arr[j], arr[i + 1] = arr[i + 1], arr[j]
            i += 1
    
    # 将基准放到正确位置（i+1）
    arr[i + 1], arr[r] = arr[r], arr[i + 1]
    
    q = i + 1
    return q


# ============= 测试代码 =============
if __name__ == "__main__":
    # 测试用例
    arr = [4, 1, 2, 5, 6, 3]
    print(f"排序前: {arr}")
    
    random_quickSort(arr, 0, len(arr) - 1)
    
    print(f"排序后: {arr}")
    
    # 验证正确性
    assert arr == [1, 2, 3, 4, 5, 6], f"排序失败！"
    print("✓ 排序正确")
```

## 次序选择问题

### 问题描述
- 输入：
    - 包含 $n$ 个不同元素的数组 $A[1..n]$
    - 整数 $k(1\leq k\leq n)$  
- 输出：
    - 数组 $A[1..n]$ 中第 $k$ 小的元素 $(1\leq k \leq n)$

### 解决思路
- 快速排序
    - 不必求得所有的元素次序
    - 步骤：
        - 选取固定位置主元 $x$ 
        - 维护两个部分的右端点变量 $i,j$
        - 考察数组元素 $A[j]$, 只和主元比较
            - 若 $A[j]\leq x$，则交换 $A[j]$ 和 $A[i+1]$ , $i$ 和 $j$ 右移
            - 若 $A[j]>x$, 则 $j$ 右移
        -  选取固定位置主元：小于主元的元素个数 $q-p$ 
            - 情况1： $k=q-p+1$ , $A[q]$ 为数组的第 $k$ 小的元素
            - 情况2： $k<q-p+1$ , $A[q]$ 在数组 $A[p..q-1]$ 中找第 $k$ 小的元素
            - 情况3： $k>q-p+1$ , $A[q]$ 在数组 $A[q+1..r]$ 中找第 $k-(q-p+1)$ 小的元素

- 次序选择问题描述
<div align="center">
<img src="./次序选择问题.svg" width="600" alt="次序选择问题" />
</div>

### 伪代码

- 固定位置次序选择
<div align="center">
<img src="./最小值查找.svg" width="600" alt="最小值查找" />
</div>

- 随机位置次序选择
<div align="center">
<img src="./随机最小值查找.svg" width="600" alt="随机最小值查找" />
</div>

# 堆排序与线性时间排序

## 优先队列

- 场景：
    - 例如使用打印机的时候，三个作业提交到打印机，队列中的元素是待打印的作业，每个作业将各自的页数作为其优先级

    - 短作业优先的方式相当于从队列中提取最小的元素

    - 当有新的作业到来的时候需要进行入队
- 操作：
    - Insert：将新元素插入到队列中
    - Extract-Min：返回队列中最小的元素并将其删除

- 实现方式：
    - 无序列表+指向最小元素的指针
        - Insert： $O(1)$
        - Extract-Min： $O(n)$ ,需要线性时间来找到最小的元素
    - 有序数组
        - Insert: $O(n)$
        - Extract-Min: $O(1)$
    - 双向有序链表
        - Insert：$O(n)$
        -Extract-Min: $O(1)$


## 二叉堆

- 定义：
    - 堆可以视为一颗完整的二叉树
        - 除最后一层节点数可能不满足之外，其余层数的节点数目都达到最大个数
        - 最后一层的节点都连续集中在最左边

<div align="center">
<img src="./二叉堆.svg" width="600" alt="二叉堆" />
</div>

- 最小堆（小根堆）
    - 父节点的值不大于其左右孩子节点的值

<div align="center">
<img src="./最小堆.svg" width="600" alt="最小堆" />
</div>

- 堆：数组的实现
    - 数组的第一个元素表示根节点
    - 对其中每个元素 $a[i]$ 
        - 其左孩子的数组下标是 $2i$ 
        - 其右孩子的数组下标是 $2i+1$ 
        - 其父节点的数组下标是 $\lfloor i/2 \rfloor$ 

- 操作
    - Insert： $O(\log n)$
    - Extract-Min： $O(\log n)$
### 插入(Insert)
- 将待插入的节点添加到最底层下一个可以使用的位置
- 不断向上调整(向上冒泡)直至满足最小堆的有序性
    - 如果父节点的值大于当前节点的值，那么交换当前节点与父节点的位置
- 正确性
    - 每次交换后，新节点为根的子树均满足最小堆的有序性
    - 时间复杂度: $O(height)=O(\log n)$ 
### 提取最小值(Extract Min)
- 将最后一个节点复制到根节点(即覆盖存储在根节点处的最小元素)
- 不断向下调整(向下冒泡)，直到满足最小堆的有序性
    - 若该节点值大于某一个孩子节点，则将其与值较小的孩子节点进行交换
- 正确性
    - 每次交换后，除该节点之外的其他节点都满足最小堆的有序性
    - 时间复杂度: $O(height)=O(\log n)$ 
## 堆排序
- 步骤
    - 建立一个有n个节点的二叉堆
        - 最小元素在堆的顶部
        - 逐一插入 $n$个元素，时间复杂度是 $O(n\log n)$

    - 执行 $n$ 次， Extract-Min的操作
        - 按顺序提取所有的节点
        - 每次执行Extract-Min的时间复杂度是 $O(\log n)$, $n$ 次是 $O(n\log n )$
    - 总体时间复杂度是： $O(n\log n)$
### 决策树模型
- 决策树模型能够模拟任意基于比较的排序算法的执行过程
- 每个大小是 $n$ 的输入都能够对应一个决策树
- 最坏情况的运行时间就是决策树的高度
## 排序算法下界
- 定理
    - 任意基于比较的排序算法都需要 $\Omega(n\log n)$次比较
- 证明
    - 对于一个模拟 $n$ 个元素排序的决策树，其至少含有 $n!$ 个叶子节点，因为共有 $n!$ 种可能的排序
    - 一个高度是 $h$ 的二叉树最多有 $2^h$ 个叶子节点
    - 因此， $n!\leq 2^h$, $h\geq \log n!=\Omega(n\log n)$ 
- 推论
    - 堆排序以及归并排序是渐进最优的基于比较的排序算法
## 计数排序

- 算法思想： 对于输入数组中的元素 $x$ ,确定小于 $x$ 的元素的数量
- 根据此信息直接将元素 $x$ 放在输出数组的对应位置


<div align="center">
<img src="./计数排序.svg" width="600" alt="计数排序" />
</div>