# 归并排序


## 引入：杠铃增重问题

背景：每位参赛运动员需要提交三次举重量，为了方便杠铃拆卸，需要对所有的试举重量进行递增排序

快速合并：比较两个有序数组当前的最小元素，将最小者合入到新数组

## 归并排序

- 分解原问题：将数组 $A[1,n]$ 分解为 $A[1,\lfloor \frac{n}{2} \rfloor]$和$A[\lfloor \frac{n}{2}  \rfloor,n]$ 排序问题
- 解决子问题：递归解决子问题得到两个有序的数组
- 合并问题解：将两个有序子数组进行合并为一个有序的数组


<div align="center">
<img src="./归并排序.svg" width="600" alt="归并排序" />
</div>

```python
# 归并排序代码

from typing import List

def merge_sort(A: List[int], left: int, right: int) -> None:
    """
    对 A[left:right] 进行原地排序（左闭右开区间）
    """
    if right - left <= 1:  # 区间少于2个元素
        return
    
    mid = (left + right) // 2  # 整数除法
    
    # 递归排序左右两半
    merge_sort(A, left, mid)
    merge_sort(A, mid, right)
    
    # 合并已排序的两半
    merge(A, left, mid, right)

def merge(A: List[int], left: int, mid: int, right: int) -> None:
    """合并 A[left:mid] 和 A[mid:right]"""
    # 复制待合并区间
    temp = A[left:right]
    
    i, j = 0, mid - left  # temp数组中的左右指针
    k = left              # 原数组中的写入位置
    
    # 合并两个有序子数组
    while i < mid - left and j < right - left:
        if temp[i] <= temp[j]:
            A[k] = temp[i]
            i += 1
        else:
            A[k] = temp[j]
            j += 1
        k += 1
    
    # 处理剩余元素
    while i < mid - left:
        A[k] = temp[i]
        i += 1
        k += 1
    
    while j < right - left:
        A[k] = temp[j]
        j += 1
        k += 1

```


## 复杂度分析

$$
T(n) = \begin{cases}
2T(n/2) + O(n), & \text{if } n > 1 \\
O(1), & \text{if } n = 1
\end{cases}
$$


- 递归树法：用树的形式表示抽象递归

<div align="center">
<img src="./递归树法.svg" width="600" alt="递归树法" />
</div>

- 代入法：

$$
T(n) = \begin{cases}
T(n/4) + T(3n/4) + O(n), & \text{if } n > 4 \\
O(1), & \text{if } n <4
\end{cases}
$$

猜测：$T(n)=\Theta(n\log n)$,即$\exist c_1,c_2,n_0>0 $,使得$\forall n\geq n_0,c_1g(n)\leq T(n)\leq c_2g(n)$

使用数学归纳法证明（不重要）



- 主定理法：（重要）

观察形如$T(n)=aT(\frac{n}{b})+f(n)$

$$
T(n) = 
\begin{cases}
O\bigl(f(n)\bigr)          & \text{if } f(n) = \Omega\!\bigl(n^{\log_b a + \epsilon}\bigr) \\[6pt]
O\bigl(n^{\log_b a}\log n\bigr) & \text{if } f(n) = \Theta\!\bigl(n^{\log_b a}\bigr) \\[6pt]
O\bigl(n^{\log_b a}\bigr)  & \text{if } f(n) = O\!\bigl(n^{\log_b a - \epsilon}\bigr)
\end{cases}
$$
比较根节点代价$f(n)$与叶节点代价之和$n^{\log_b a}$


<div align="center">
<img src="./主定理.svg" width="600" alt="主定理" />
</div>


- 主定理简化（**重要**）

对形如 $T(n) = aT(n/b) + n^k$ 的递归式：
$$
T(n) = 
\begin{cases}
O\bigl(n^k\bigr)            & \text{if } k > \log_b a \\[6pt]
O\bigl(n^k \log n\bigr)     & \text{if } k = \log_b a \\[6pt]
O\bigl(n^{\log_b a}\bigr)   & \text{if } k < \log_b a
\end{cases}
$$

- 主定理扩展

对形如 $T(n) = aT(n/b) + f(n)$ 的递归式：
$$
T(n) = \begin{cases}
O(f(n)) & \text{if } f(n) = \Omega(n^{\log_b a + \epsilon}) \text{（情况1）} \\
O(n^{\log_b a} \log^{k+1} n) & \text{if } f(n) = \Theta(n^{\log_b a} \log^k n), \, k \geq 0 \text{（情况2）} \\
O(n^{\log_b a}) & \text{if } f(n) = O(n^{\log_b a - \epsilon}) \text{（情况3）}
\end{cases}
$$
对于情况2，情况2的扩展

$$
T(n) = \begin{cases}
O\bigl(n^{\log_b a} \log^{k+1} n\bigr) & \text{if } k > -1 \\[6pt]
O\bigl(n^{\log_b a} \log\log n\bigr)   & \text{if } k = -1 \\[6pt]
O\bigl(n^{\log_b a}\bigr)              & \text{if } k < -1
\end{cases}
$$

<div align="center">
<img src="./主定理扩展.svg" width="600" alt="主定理扩展" />
</div>

## 主定理例子
例子1：

$T(n)=5T(n/2)+n^3$

**参数识别**：
- $a = 5, b = 2, k = 3$
- $\log_b a = \log_2 5$

**情况判断**：
$$ k = 3 > \log_2 5 $$

属于 **情况①**，因此：
$$ T(n) = O(n^k) = O(n^3) $$



例子2：

$T(n)=4T(n/4)+n^{1/2}$

**参数识别**：
- $a = 4, b = 4, k = \frac{1}{2}$
- $\log_b a = \log_4 4 = 1$

**情况判断**：
$$ k = \frac{1}{2} < \log_4 a = 1 $$

属于 **情况③**，因此：
$$ T(n) = O(n^{\log_b a}) = O(n) $$

例子3：

$T(n)=3T(n/4)+n\log n$


**参数识别**：
- $a = 3, b = 4$
- $\log_b a = \log_4 3 < 1$

**正则条件验证**：
存在 $\varepsilon > 0$ 使得 $\log_4 3 + \varepsilon < 1$，故：
$$ f(n) = n\log n = \Omega(n^{\log_b a + \varepsilon}) $$

且 $af(n/b) = 3 \cdot \frac{n}{4}\log\frac{n}{4} < cf(n)$ 对某个 $c < 1$ 成立

属于 **情况①**，因此：
$$ T(n) = O(f(n)) = O(n\log n) $$

例子4：

$T(n)=2T(n/2)+n\log n$

**参数识别**：
- $a = 2, b = 2, k = 1$
- $\log_b a = \log_2 2 = 1$

**情况分析**：
- $f(n) = n\log n$ 与 $n^{\log_b a} = n$ 比较
- 然而对任意 $\varepsilon > 0$，$\log n$ 渐进小于 $n^\varepsilon$
- 不存在 $\varepsilon > 0$ 使 $f(n) = \Omega(n^{1+\varepsilon})$

**结论**：该情况落入情况①和②之间，**不能使用主定理**，需用递归树法求解，结果为 $T(n) = O(n\log^2 n)$


# 经典问题

## 最大子数组问题I

### 问题描述
- 名称：MaxContinuousSubarray, MCS
- 问题背景：子数组是原数组中的一段序列
- 输入：给定一个数字组$X[1..n]$,对于任意一对数组下标为$l,r(l\leq r)$的非空子数组
$$S(l,r)=\sum_{i=l}^{r}X[i]$$
- 输出：求出$S(l,r)$的最大值，记为$S_{max}$


### 解决思路

- 蛮力枚举：数组$X[1..n]$,其所有的下标$l,r(l\leq r)$组合分分为几种情况

  - 当 $l=r$ ，一共有n种组合
  - 当 $l<r$ ，一共有$C_n^2$种组合

<div align="center">
<img src="./mcs-1.svg" width="600" alt="mcs-1" />
</div>

- 优化枚举：利用之前已经计算的数据
$S(l,r)=\sum_{i=l}^{r}X[i]=S(l,r-1)+X[r]$


<div align="center">
<img src="./mcs-2.svg" width="600" alt="mcs-2" />
</div>

- 分而治之

    - 将数组$X[1..n]$分为$X[1..n/2]$和$X[n/2+1..n]$
    - 递归求解子问题：
        - $S_1$:数组$X[1..n/2]$的最大子数组
        - $S_2$:数组$X[n/2+1...n]$的最大子数组
    - 合并子问题：得到 $S_{max}$
        - $S_3$:跨中点的最大子数组
        - 数组$X$的最大子数组之和$S_{max}=\max\{S_1,S_2,S_3\}$

    - 求解$S_3$
        - 记$mid=n/2$
        - $S_3$分为左右两部分,$S_3=left+right$
            - left:以$X[mid]$为结尾的最大子数组之和
            - right:以$X[mid+1]$为开头的最大子数组之和
            - 分别求出left，right便可求出$S_3$
i

### 伪代码

<div align="center">
<img src="./mcs-3.svg" width="600" alt="mcs-3" />
</div>

## 逆序对计数问题

### 问题描述
- 名称：逆序对计数问题Counting Inversions(CI)
- 输入：长度为$n$的数组$A[1..n]$
- 输出：数组$A[1..n]$逆序对的总数，
$$\sum_{1\leq i< j \leq n}X_{i,j}$$

$$
X_{i,j} = \begin{cases}
1 &  A[i]>A[j] \\
0 &  A[i]\leq A[j]
\end{cases}
$$

### 解决思路

- 蛮力枚举：对于数组的每个元素$A[i]$,枚举$j(j>i)$,并统计逆序对数目

<div align="center">
<img src="./CI-1.svg" width="600" alt="CI-1" />
</div>

- 分而治之：

    - 将数组$A[1..n]$分为$A[1..n/2]$和$A[n/2+1..n]$
    - 递归求解子问题：
        - $S_1$:数组$A[1..n/2]$的逆序对数目
        - $S_2$:数组$A[n/2+1...n]$的逆序对数目
    - 合并$A[1..n/2]$和$A[n/2+1...n]$的解
        - $S_3$:跨越子数组的逆序对数目
        - $S=S_1+S_2+S_3$

    - 策略1，直接求解
        - 求解方法：对每个$A[j]\in A[m+1..n]$,枚举$A[i]\in A[1..m]$并统计逆序对数目，导致求解$S_3$的算法运行时间是$O(n^2)$,分而治之框架的算法运行时间是$T(n)=2\cdot T(n/2)+O(n^2)$
        - 致因分析：运行时间受制于跨越子数组的逆序对计数方法，数组的有序性通常有助于提高算法的运行时间

    - 策略2，排序求解
        - 求解方法：
            - 1.分别对每个数组$A[1..m]$和$A[m+1..n]$进行排序
            - 2.对于每个$A[j]\in A[m+1..n]$，采用二分查找为其在$A[1..m]$中的定位
            - 3.$A[j]$在$A[1..m]$定位点右侧的元素均可以与$A[j]$构成逆序对
            - 4.求解$S_3$的算法运行时间$O(n\log n)$
            - 5.分而治之框架的算法运行时间：$T(n)=2T(n/2)+O(n\log n)$
        - 致因分析：未将排序过程融入整个算法框架
    - 策略3，归并求解
        - 求解方法：
            - 1.从左到右扫描有序子数组：$A[i]\in A[1..m]$,$A[j]\in A[m+1..n]$
                - 如果$A[i]>A[j]$,统计逆序对，$j$右移
                - 如果$A[i]\leq A[j]$,$i$右移
            - 2.利用归并排序框架保证合并之后数组的有序性

<div align="center">
<img src="./CI-2.svg" width="600" alt="CI-2" />
</div>

<div align="center">
<img src="./CI-3.svg" width="600" alt="CI-3" />
</div>

<div align="center">
<img src="./CI-4.svg" width="600" alt="CI-4" />
</div>

### 伪代码


<div align="center">
<img src="./CI-5.svg" width="600" alt="CI-5" />
</div>

```
分而治之的策略的关键是什么？

答案：合理设计合并求解算法
```

## 多项式乘法问题

- 问题背景：
    - $A(x)=1+2x+3x^2$
    - $B(x)=3+2x+2x^2$
    - $C(x)=A(x)B(x)=3+8x+15x^2+10x^3+6x^4$
- 数据表示：
    - $A(x)$的系数向量：$A=(1,2,3)$
    - $B(x)$的系数向量：$B=(3,2,2)$
    - $C(x)$的系数向量：$C=(3,8,15,10,6)$
- 性能指标：
    - 标量的乘法和加法操作

- 名称：Polynomial Multiplication problem
- 输入：两个多项式
    - $A(x)=a_0+a_1 x+...a_n x^n$
    - $B(x)=b_0+b_1 x+...b_n x^n$
- 输出：两个多项式的乘积
    - $C(x)=A(x)B(x)=\sum_{k=0}^{n+m}c_k x^k$
    - 其中$c_k=\sum_{0\leq i\leq n,0\leq j\leq m,i+j=k}a_ib_j,0\leq k\leq m+n$


### 问题思路

- 普通分治
    - 具体做法：四次递归，分别求解$A_0(x)B_0(x),A_0(x)B_1(x),A_1(x)B_0(x),A_1(x)B_1(x)$
    - 合并问题解：$A(x)B(x)=A_0(x)B_0(x)+A_1(x)B_0(x)x^{n/2}+A_0(x)B_1(x)x^{n/2}+A_1(x)B_1(x)x^{n}$
- 合并同类项
    - $A(x)B(x)=A_0(x)B_0(x)+[A_1(x)B_0(x)+A_0(x)B_1(x)]x^{n/2}+A_1(x)B_1(x)x^{n}$
    - 三次递归：$Y=(A_0+A_1)(B_0+B_1)$，$U=A_0B_0$，$Z=A_1B_1$，$A_1B_0+A_0B_1=Y-U-Z$

# 快速排序

## 基本思想

快速排序：侧重分解，简化合并

