import math
from collections import deque

def BFS(G, s):
    """
    广度优先搜索（BFS）算法
    
    参数:
        G: 图的邻接表表示（字典），键为顶点，值为邻居列表
        s: 源点（起始顶点）
    
    返回:
        color: 顶点颜色数组（white=未访问, gray=已发现, black=已处理）
        dist: 源点到各顶点的最短距离
        pred: 前驱顶点数组（记录搜索树）
    """
    
    # 获取图中所有顶点的数量
    # 注意：顶点编号可能不连续，这里取最大顶点编号作为数组大小
    max_vertex = max(G.keys())
    
    # ------------------------------------------------------------------
    # 阶段1: 初始化所有顶点的状态
    # ------------------------------------------------------------------
    # color: 访问状态，"white"=未访问, "gray"=已发现, "black"=已处理
    color = ["white"] * (max_vertex + 1)
    
    # dist: 从源点s到每个顶点的距离，初始化为无穷大
    dist = [math.inf] * (max_vertex + 1)
    
    # pred: 前驱顶点（在BFS树中的父节点），None表示无前驱
    pred = [None] * (max_vertex + 1)
    
    # ------------------------------------------------------------------
    # 阶段2: 初始化源点s
    # ------------------------------------------------------------------
    # 源点标记为已发现（灰色）
    color[s] = "gray"
    # 源点到自身的距离为0
    dist[s] = 0
    # 源点无前驱
    pred[s] = None
    
    # ------------------------------------------------------------------
    # 阶段3: 创建FIFO队列并加入源点
    # ------------------------------------------------------------------
    # 重要：BFS必须使用FIFO队列（先进先出），不能使用优先队列
    # collections.deque是Python的双端队列，popleft()为O(1)，适合BFS
    Q = deque()
    Q.append(s)  # 将源点加入队列尾部
    
    # ------------------------------------------------------------------
    # 阶段4: 主循环——处理队列中的顶点
    # ------------------------------------------------------------------
    while Q:
        # 从队列头部取出顶点u（FIFO顺序）
        u = Q.popleft()
        
        # 遍历u的所有邻居v
        for v in G[u]:
            # 如果邻居v未被访问过（白色）
            if color[v] == "white":
                # 标记为已发现（灰色）
                color[v] = "gray"
                # 距离 = 前驱距离 + 1
                dist[v] = dist[u] + 1
                # 记录前驱为u
                pred[v] = u
                # 将v加入队列尾部（后续处理）
                Q.append(v)
        
        # u的所有邻居处理完毕，标记为已处理（黑色）
        color[u] = "black"
    
    # ------------------------------------------------------------------
    # 阶段5: 返回结果
    # ------------------------------------------------------------------
    return color, dist, pred


# ------------------------------------------------------------------
# 测试用例
# ------------------------------------------------------------------
if __name__ == "__main__":
    # 图的邻接表表示
    # 键为顶点编号，值为邻居列表（无向图）
    G = {
        1: [2, 5],
        2: [1, 6],
        3: [4, 6, 7],
        4: [3, 7, 8],
        5: [1],
        6: [2, 3, 7],
        7: [3, 4, 6, 8],
        8: [4, 7]
    }
    
    # 源点
    s = 2
    
    # 执行BFS
    color, dist, pred = BFS(G, s)
    
    # ------------------------------------------------------------------
    # 打印结果
    # ------------------------------------------------------------------
    print("="*50)
    print(f"BFS从源点 {s} 开始的结果")
    print("="*50)
    
    # 获取所有顶点并排序
    vertices = sorted(G.keys())
    
    print("\n顶点访问状态 (color):")
    for v in vertices:
        print(f"  顶点 {v}: {color[v]}")
    
    print("\n到源点的最短距离 (dist):")
    for v in vertices:
        if dist[v] == math.inf:
            print(f"  顶点 {v}: 不可达")
        else:
            print(f"  顶点 {v}: {int(dist[v])}")
    
    print("\n前驱顶点 (pred) - BFS树:")
    for v in vertices:
        if pred[v] is None:
            if v == s:
                print(f"  顶点 {v}: 源点（无前驱）")
            else:
                print(f"  顶点 {v}: 不可达")
        else:
            print(f"  顶点 {v}: 前驱是 {pred[v]}")
    
    print("\nBFS遍历顺序（按发现顺序）:")
    # 根据距离和发现时间重构遍历顺序
    order = sorted([(v, dist[v]) for v in vertices if dist[v] != math.inf], 
                   key=lambda x: x[1])
    print(" → ".join(str(v[0]) for v in order))
    print("="*50)