import math

def DFS(G):
    """
    深度优先搜索（DFS）算法 - 计算发现时间和结束时间
    
    参数:
        G: 图的邻接表表示（字典），键为顶点，值为邻居列表
    
    返回:
        pred: 前驱顶点数组（DFS森林）
        d: 发现时刻数组
        f: 结束时刻数组
    """
    # 获取最大顶点编号以确保数组大小足够
    max_vertex = max(G.keys())
    
    # ------------------------------------------------------------------
    # 阶段1: 初始化所有顶点的状态数组
    # ------------------------------------------------------------------
    # color: 访问状态，"white"=未访问, "gray"=已发现, "black"=已处理
    color = ["white"] * (max_vertex + 1)
    
    # pred: 前驱顶点（DFS树中的父节点），None表示无前驱
    pred = [None] * (max_vertex + 1)
    
    # d: 发现时刻（顶点首次被访问的时间），初始化为0
    d = [0] * (max_vertex + 1)
    
    # f: 结束时刻（顶点及其子树处理完毕的时间），初始化为0
    f = [0] * (max_vertex + 1)
    
    # ------------------------------------------------------------------
    # 阶段2: 时间计数器（使用列表实现引用传递）
    # ------------------------------------------------------------------
    # Python中整数是不可变的，为了在递归中正确更新时间，
    # 使用列表time[0]来存储时间戳（列表是可变对象）
    time = [0]
    
    # ------------------------------------------------------------------
    # 阶段3: 遍历所有顶点，处理每个连通分量
    # ------------------------------------------------------------------
    # 从1到max_vertex遍历，确保所有顶点都被访问
    for v in range(1, max_vertex + 1):
        # 如果顶点v存在且未被访问
        if v in G and color[v] == "white":
            # 递归访问顶点v所在的连通分量
            DFS_visit(G, v, color, d, f, pred, time)
    
    # ------------------------------------------------------------------
    # 阶段4: 返回结果
    # ------------------------------------------------------------------
    return pred, d, f


def DFS_visit(G, v, color, d, f, pred, time):
    """
    DFS递归访问函数
    
    参数:
        G: 图的邻接表
        v: 当前访问的顶点
        color: 颜色数组
        d: 发现时间数组
        f: 结束时间数组
        pred: 前驱数组
        time: 时间计数器（列表形式，用于引用传递）
    """
    # ------------------------------------------------------------------
    # 阶段1: 发现顶点v
    # ------------------------------------------------------------------
    # 将顶点标记为灰色（已发现但未处理完毕）
    color[v] = "gray"
    
    # 时间计数器加1
    time[0] += 1
    
    # 记录顶点v的发现时间
    d[v] = time[0]
    
    # ------------------------------------------------------------------
    # 阶段2: 递归访问所有白色邻居
    # ------------------------------------------------------------------
    # 遍历顶点v的所有邻居w
    for w in G[v]:
        # 如果邻居w未被访问（白色）
        if color[w] == "white":
            # 设置w的前驱为v（构建DFS树）
            pred[w] = v
            
            # 递归访问w
            DFS_visit(G, w, color, d, f, pred, time)
    
    # ------------------------------------------------------------------
    # 阶段3: 完成顶点v的处理
    # ------------------------------------------------------------------
    # 将顶点标记为黑色（已处理完毕）
    color[v] = "black"
    
    # 时间计数器加1
    time[0] += 1
    
    # 记录顶点v的结束时间
    f[v] = time[0]


# ------------------------------------------------------------------
# 主程序测试
# ------------------------------------------------------------------
if __name__ == "__main__":
    # 图的邻接表表示（无向图）
    G = {
        1: [2, 5],
        2: [1, 6],
        3: [4, 6, 7],
        4: [3, 7, 8],
        5: [1],
        6: [2, 3, 7],
        7: [3, 4, 6, 8],
        8: [4, 7]
    }
    
    # 从顶点2开始执行DFS
    pred, d, f = DFS(G)
    
    # ------------------------------------------------------------------
    # 打印结果
    # ------------------------------------------------------------------
    print("="*60)
    print("深度优先搜索（DFS）结果 - 从顶点2开始")
    print("="*60)
    
    # 获取所有顶点并排序
    vertices = sorted(G.keys())
    
    print("\n前驱顶点 (pred) - DFS树:")
    for v in vertices:
        if pred[v] is None:
            if v == 2:  # 假设从2开始
                print(f"  顶点 {v}: 根节点")
            else:
                print(f"  顶点 {v}: 不可达")
        else:
            print(f"  顶点 {v}: 前驱是 {pred[v]}")
    
    print("\n发现时间 (d):")
    for v in vertices:
        print(f"  顶点 {v}: {d[v]}")
    
    print("\n结束时间 (f):")
    for v in vertices:
        print(f"  顶点 {v}: {f[v]}")
    
    print("\n括号表示法（区间包含关系）:")
    for v in vertices:
        if d[v] > 0:
            print(f"  {v}: [{d[v]}, {f[v]}]")
    
    print("="*60)
    print(f"最大顶点编号: {max(G.keys())}")
    print(f"数组大小验证: len(pred)={len(pred)}")
    print("="*60)