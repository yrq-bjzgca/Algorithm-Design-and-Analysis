def Longest_Common_Subsequence(X, Y):
    """
    计算两个字符串的最长公共子序列 (LCS - Longest Common Subsequence)
    与子串不同，子序列不要求字符连续，只要求相对顺序保持不变
    
    参数:
        X: 字符串1
        Y: 字符串2
    
    返回:
        C: DP表，C[i][j]表示X[0:i]和Y[0:j]的LCS长度
        Rec: 记录表，标记每一步的路径方向，用于后续回溯构造LCS
    """
    n = len(X)  # 字符串X的长度
    m = len(Y)  # 字符串Y的长度
    
    # ------------------------------------------------------------------
    # 阶段1: 初始化DP表和记录表
    # ------------------------------------------------------------------
    # C[i][j] 表示 X[0:i] 和 Y[0:j] 的最长公共子序列长度
    # 需要 (n+1) x (m+1) 的二维表，额外的一行一列处理空字符串的边界情况
    # i=0 表示X为空字符串, j=0 表示Y为空字符串，此时LCS长度为0
    C = [[0] * (m + 1) for _ in range(n + 1)]
    
    # Rec[i][j] 记录到达C[i][j]的路径方向，用于回溯时重构LCS
    # "LU" 表示来自左上角 (i-1, j-1)，说明X[i-1]==Y[j-1]且该字符被选中
    # "U"  表示来自上方 (i-1, j)，说明跳过X[i-1]这个字符
    # "L"  表示来自左方 (i, j-1)，说明跳过Y[j-1]这个字符
    Rec = [[""] * (m + 1) for _ in range(n + 1)]
    
    # ------------------------------------------------------------------
    # 阶段2: 填充DP表（动态规划核心）
    # ------------------------------------------------------------------
    # 遍历字符串X的每个字符（从1开始，因为第0行是边界）
    for i in range(1, n + 1):
        
        # 遍历字符串Y的每个字符
        for j in range(1, m + 1):
            
            # 情况1: 当前字符匹配
            # X[i-1] 是字符串X的第i个字符（0-based索引）
            # Y[j-1] 是字符串Y的第j个字符（0-based索引）
            if X[i - 1] == Y[j - 1]:
                # 如果字符匹配，LCS长度 = 左上角值 + 1
                # 因为当前字符可以加入公共子序列
                C[i][j] = C[i - 1][j - 1] + 1
                Rec[i][j] = "LU"  # 标记方向为左上角
                
            # 情况2: 当前字符不匹配
            # 需要比较两个方向：跳过X[i-1] 或 跳过Y[j-1]
            # 选择能使LCS更长的那个方向
            elif C[i - 1][j] > C[i][j - 1]:
                # 如果上方单元格的值更大，说明跳过X[i-1]更有利
                C[i][j] = C[i - 1][j]
                Rec[i][j] = "U"  # 标记方向为上方
                
            else:
                # 否则左方单元格的值更大或相等，跳过Y[j-1]
                C[i][j] = C[i][j - 1]
                Rec[i][j] = "L"  # 标记方向为左方
    
    # ------------------------------------------------------------------
    # 阶段3: 返回结果
    # ------------------------------------------------------------------
    return C, Rec


def Print_LCS(Rec, X, i, j):
    """
    根据记录表Rec回溯并打印最长公共子序列
    
    参数:
        Rec: 记录表（来自Longest_Common_Subsequence函数）
        X: 字符串X
        i: 当前行索引（从len(X)开始回溯）
        j: 当前列索引（从len(Y)开始回溯）
    """
    # ------------------------------------------------------------------
    # 阶段4: 递归回溯（从右下角向左上角追溯）
    # ------------------------------------------------------------------
    # 边界条件：如果任一索引为0，表示已到达空字符串，递归结束
    if i == 0 or j == 0:
        return
    
    # 情况1: 方向为"LU"，表示X[i-1]==Y[j-1]且该字符属于LCS
    if Rec[i][j] == "LU":
        # 先递归处理左上角（处理前面的子问题）
        Print_LCS(Rec, X, i - 1, j - 1)
        # 打印当前字符（注意是X[i-1]，因为i是DP表索引）
        # end='' 表示不换行，字符会连续输出
        print(X[i - 1], end='')
    
    # 情况2: 方向为"U"，表示跳过X[i-1]
    # 只需要向上递归（i-1, j保持不变）
    elif Rec[i][j] == "U":
        Print_LCS(Rec, X, i - 1, j)
    
    # 情况3: 方向为"L"，表示跳过Y[j-1]
    # 只需要向左递归（i保持不变, j-1）
    elif Rec[i][j] == "L":
        Print_LCS(Rec, X, i, j - 1)


# ------------------------------------------------------------------
# 主程序测试
# ------------------------------------------------------------------
if __name__ == "__main__":
    # 测试用例
    X = "ABCBDAB"
    Y = "BDCABA"
    
    # 计算LCS
    C, Rec = Longest_Common_Subsequence(X, Y)
    
    # 打印DP表（调试用）
    print("DP表 C:")
    for row in C:
        print(row)
    
    print("\n记录表 Rec:")
    for row in Rec:
        print(row)
    
    # 获取字符串长度作为回溯起点
    i = len(X)
    j = len(Y)
    
    # 打印最终结果
    print(f"\n字符串X: {X}")
    print(f"字符串Y: {Y}")
    print(f"最长公共子序列: ", end='')
    Print_LCS(Rec, X, i, j)
    print()  # 换行
    print(f"长度: {C[i][j]}")
    
    # 验证结果
    print(f"\n验证: DP表右下角值 C[{i}][{j}] = {C[i][j]}")