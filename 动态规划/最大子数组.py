def max_continuous_subarray_dp(X, n):
    """
    使用动态规划求解最大连续子数组和问题（Kadane算法变种）
    
    参数:
        X: 整数列表，表示给定的数组
        n: 数组长度
    
    返回:
        Smax: 最大连续子数组的和
        l: 最大子数组的左边界索引（0-based）
        r: 最大子数组的右边界索引（0-based）
    
    算法思路:
        反向遍历数组，D[i]表示从位置i开始的最大子数组和。
        如果D[i+1]为正，则合并；否则从i重新开始。
        Rec[i]记录从i开始的子数组的右边界。
    """
    
    # ------------------------------------------------------------------
    # 阶段1: 初始化DP数组和记录数组
    # ------------------------------------------------------------------
    # D[i] 表示从位置 i 开始的最大连续子数组和
    # 为方便处理边界，D长度为n+1，D[n] = 0作为哨兵
    # D[n] = 0 表示数组末尾之外的子数组和为0
    D = [0] * (n + 1)
    
    # Rec[i] 记录从 i 开始的子数组的右边界（结束索引）
    # 即：从 i 到 Rec[i] 的子数组和为 D[i]
    Rec = [0] * (n + 1)
    
    # ------------------------------------------------------------------
    # 阶段2: 反向动态规划（从右往左计算）
    # ------------------------------------------------------------------
    # 为什么反向？因为 D[i] 依赖 D[i+1]（右边的结果）
    # 循环 i 从 n-1 递减到 0（包含0）
    for i in range(n - 1, -1, -1):
        
        # 情况A：如果右边子数组的和为正，则合并扩展
        # D[i+1] 表示从 i+1 开始的子数组和
        if D[i + 1] > 0:
            # 合并：从i开始的和 = 当前元素X[i] + 右边正数和
            D[i] = X[i] + D[i + 1]
            # 右边界继承：从i开始的子数组右边界 = 从i+1开始的右边界
            Rec[i] = Rec[i + 1]
        
        # 情况B：如果右边子数组的和为非正，则重新开始
        else:
            # 重新开始：从i开始的和就是X[i]本身
            D[i] = X[i]
            # 右边界重置为i（子数组只有当前元素）
            Rec[i] = i
    
    # ------------------------------------------------------------------
    # 阶段3: 在DP数组中查找全局最大值
    # ------------------------------------------------------------------
    # 初始设置：假设最大值在索引0处
    # Smax 存储最大和，l和r存储对应的左右边界
    Smax = D[0]    # 初始最大和
    l = 0          # 初始左边界
    r = Rec[0]     # 初始右边界
    
    # 遍历所有位置 i 从 1 到 n-1
    for i in range(1, n):
        # 如果找到更大的和
        if Smax < D[i]:
            # 更新最大值和对应的边界
            Smax = D[i]      # 更新最大和
            l = i            # 更新左边界为当前i
            r = Rec[i]       # 更新右边界为Rec[i]记录的边界
    
    # ------------------------------------------------------------------
    # 阶段4: 返回结果
    # ------------------------------------------------------------------
    return Smax, l, r


# ------------------------------------------------------------------
# 主程序测试
# ------------------------------------------------------------------
if __name__ == "__main__":
    # 测试数组
    X = [1, -2, 4, 5, -2, 8, 3, -2, 6, 3, 7, -1]
    n = len(X)
    
    # 打印基本信息
    print(f"数组长度: {n}")
    print(f"数组内容: {X}")
    
    # 调用函数并获取结果
    result = max_continuous_subarray_dp(X, n)
    
    # ------------------------------------------------------------------
    # 阶段5: 结果验证与输出
    # ------------------------------------------------------------------
    Smax, l, r = result
    
    # 打印结果
    print(f"最大子数组和: {Smax}")
    print(f"子数组范围: X[{l}:{r+1}]")
    print(f"子数组内容: {X[l:r+1]}")
    
    # 手动验证
    total = sum(X[l:r+1])
    print(f"手动验证和: {total}")