def KnasackDP(n, p, v, C):
    """
    0/1背包问题的动态规划解决方案
    
    参数说明:
        n: 物品数量 (int)
        p: 物品价值列表 (list)，p[i]表示第i个物品的价值
        v: 物品体积列表 (list)，v[i]表示第i个物品的体积
        C: 背包总容量 (int)
    
    返回:
        最大价值 (int)
    
    算法核心思想:
        构建DP表P[i][c]，表示考虑前i+1个物品、在容量c限制下的最大价值
        Rec[i][c]记录是否选择第i个物品，用于后续回溯
    """
    
    # ------------------------------------------------------------------
    # 阶段1: 初始化DP表和选择记录表
    # ------------------------------------------------------------------
    # 修复1: DP表维度为 n x (C+1)
    # 因为有n个物品，每个物品对应一行；容量范围是0到C，共C+1列
    # 这种设计将第0行用于第一个物品，而不是传统DP的"0个物品"状态
    P = [[0] * (C + 1) for _ in range(n)]    # P[i][c] = 最大价值
    Rec = [[0] * (C + 1) for _ in range(n)]  # Rec[i][c] = 1表示选择第i个物品
    
    # ------------------------------------------------------------------
    # 阶段2: 初始化第一个物品（物品0）
    # ------------------------------------------------------------------
    # 为什么要单独处理第一个物品？
    # 因为DP表的第0行对应的就是物品0，没有"前0个物品"的行
    # 对于容量c >= 物品0体积的情况，可以直接放入物品0
    for c in range(v[0], C + 1):  # 遍历从物品0体积到最大容量的所有容量
        P[0][c] = p[0]            # 放入物品0，获得其价值
        Rec[0][c] = 1             # 标记为"选择"
    
    # ------------------------------------------------------------------
    # 阶段3: 填充DP表（动态规划核心）
    # ------------------------------------------------------------------
    # 遍历物品1到物品n-1（共n-1个物品）
    # i是物品的索引，也是DP表的行索引
    for i in range(1, n):
        # 遍历所有可能的容量c（从1到C）
        # c是背包的当前容量限制，也是DP表的列索引
        for c in range(1, C + 1):
            
            # 情况A: 尝试放入当前物品i
            # 条件1: v[i] <= c 表示物品i能装得下
            # 条件2: p[i] + P[i-1][c-v[i]] > P[i-1][c] 表示放入后总价值更高
            # P[i-1][c-v[i]] 表示在剩余容量下的最优价值
            if v[i] <= c and (p[i] + P[i-1][c-v[i]] > P[i-1][c]):
                P[i][c] = p[i] + P[i-1][c-v[i]]  # 选择物品i后的总价值
                Rec[i][c] = 1                     # 标记为"选择"
            
            # 情况B: 不放入当前物品i
            # 要么装不下，要么放入后价值不划算
            else:
                P[i][c] = P[i-1][c]  # 直接继承前一状态的价值
                Rec[i][c] = 0        # 标记为"不选择"
    
    # ------------------------------------------------------------------
    # 阶段4: 回溯找出选择了哪些物品
    # ------------------------------------------------------------------
    # 从DP表的右下角开始回溯，即考虑所有物品、容量为C的状态
    K = C  # K表示当前剩余容量
    
    # 从最后一个物品倒序遍历到第一个物品
    # range(n-1, -1, -1) 生成: n-1, n-2, ..., 0
    selected = []  # 存储被选中的物品索引
    for i in range(n-1, -1, -1):
        if Rec[i][K] == 1:  # 如果Rec[i][K]==1，说明物品i被选中
            selected.append(i)  # 记录物品索引
            print(f"选取物品{i}")  # 打印选择信息
            K = K - v[i]  # 剩余容量减少该物品的体积
        else:
            print(f"不选取物品{i}")  # 打印不选择信息
    
    # ------------------------------------------------------------------
    # 阶段5: 返回结果
    # ------------------------------------------------------------------
    # P[n-1][C] 是DP表的右下角，表示考虑所有n个物品、容量为C时的最大价值
    max_value = P[n-1][C]
    print(f"\n最大价值: {max_value}")
    
    return max_value


# ------------------------------------------------------------------
# 测试代码
# ------------------------------------------------------------------
if __name__ == "__main__":
    # 物品体积列表 (索引0到4对应5个物品)
    v = [10, 3, 4, 5, 4]
    
    # 物品价值列表
    p = [24, 2, 9, 10, 9]
    
    # 背包总容量
    C = 13
    
    # 物品数量
    n = 5
    
    # 调用函数并打印结果
    result = KnasackDP(n, p, v, C)
    print(f"函数返回值: {result}")
