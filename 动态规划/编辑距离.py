def Minimum_Edit_Distance(s, t):
    """
    计算两个字符串之间的最小编辑距离（Levenshtein距离）
    支持的操作：插入、删除、替换（替换代价为1）
    
    参数:
        s: 源字符串
        t: 目标字符串
    
    返回:
        D: DP表，D[i][j]表示s[0:i]转换为t[0:j]的最小编辑距离
        Rec: 记录表，标记每一步的最优操作方向，用于回溯
    """
    n = len(s)  # 源字符串长度
    m = len(t)  # 目标字符串长度
    
    # ------------------------------------------------------------------
    # 阶段1: 初始化DP表和记录表
    # ------------------------------------------------------------------
    # D[i][j] 表示将 s[0:i]（前i个字符）转换为 t[0:j]（前j个字符）的最小编辑距离
    # 表格大小为 (n+1) x (m+1)，额外的一行一列处理空字符串边界
    # i=0 表示s为空字符串, j=0 表示t为空字符串，此时转换距离为i或j
    D = [[0] * (m + 1) for _ in range(n + 1)]
    
    # Rec[i][j] 记录到达D[i][j]的最优操作方向
    # "LU" 表示替换/匹配操作（从(i-1,j-1)来）
    # "U"  表示删除操作（从(i-1,j)来）
    # "L"  表示插入操作（从(i,j-1)来）
    Rec = [[""] * (m + 1) for _ in range(n + 1)]
    
    # ------------------------------------------------------------------
    # 阶段2: 初始化边界条件
    # ------------------------------------------------------------------
    # 将空字符串s（i=0）转换为非空字符串t（j>0）：需要j次插入操作
    for j in range(m + 1):
        D[0][j] = j
        if j > 0:  # 第0列不需要标记方向（已经是边界）
            Rec[0][j] = "L"  # 插入操作，从(0,j-1)来
    
    # 将非空字符串s（i>0）转换为空字符串t（j=0）：需要i次删除操作
    for i in range(n + 1):
        D[i][0] = i
        if i > 0:  # 第0行不需要标记方向
            Rec[i][0] = "U"  # 删除操作，从(i-1,0)来
    
    # ------------------------------------------------------------------
    # 阶段3: 填充DP表（动态规划核心）
    # ------------------------------------------------------------------
    # 遍历源字符串s的每个字符（行）
    for i in range(1, n + 1):
        # 遍历目标字符串t的每个字符（列）
        for j in range(1, m + 1):
            
            # 如果当前字符相同，则无需编辑（替换代价c=0）
            # 如果不同，则需要替换（替换代价c=1）
            cost_replace = 0 if s[i - 1] == t[j - 1] else 1
            
            # 三种可能的操作：
            # 1. 替换/匹配：从D[i-1][j-1]来，加上替换代价
            replace = D[i - 1][j - 1] + cost_replace
            
            # 2. 删除：从D[i-1][j]来（删除s[i-1]），代价+1
            delete = D[i - 1][j] + 1
            
            # 3. 插入：从D[i][j-1]来（插入t[j-1]），代价+1
            insert = D[i][j - 1] + 1
            
            # 选择三种操作中代价最小的
            min_cost = min(replace, delete, insert)
            
            # 根据最小代价更新DP表和记录表
            if replace == min_cost:
                D[i][j] = replace
                Rec[i][j] = "LU"  # 替换/匹配操作
            elif delete == min_cost:
                D[i][j] = delete
                Rec[i][j] = "U"   # 删除操作
            else:
                D[i][j] = insert
                Rec[i][j] = "L"   # 插入操作
    
    # ------------------------------------------------------------------
    # 阶段4: 返回结果
    # ------------------------------------------------------------------
    return D, Rec


def Print_MED(Rec, s, t, i, j):
    """
    根据记录表Rec回溯并打印具体的编辑操作序列
    
    参数:
        Rec: 记录表（来自Minimum_Edit_Distance函数）
        s: 源字符串
        t: 目标字符串
        i: 当前行索引（从len(s)开始回溯）
        j: 当前列索引（从len(t)开始回溯）
    """
    # ------------------------------------------------------------------
    # 阶段5: 递归回溯（从右下角向左上角追溯）
    # ------------------------------------------------------------------
    # 边界条件：如果两个索引都为0，表示已回到起点，递归结束
    if i == 0 and j == 0:
        return
    
    # 情况1: 方向为"LU"，表示替换或匹配操作
    if Rec[i][j] == "LU":
        # 先递归处理左上角（处理前面的子问题）
        Print_MED(Rec, s, t, i - 1, j - 1)
        # 判断具体操作类型
        if s[i - 1] == t[j - 1]:
            print(f"字符'{s[i-1]}'匹配，无需操作")
        else:
            print(f"将'{s[i-1]}'替换为'{t[j-1]}'")
    
    # 情况2: 方向为"U"，表示删除操作
    # 从(i-1,j)转移到(i,j)，需要删除s[i-1]
    elif Rec[i][j] == "U":
        # 先递归处理上方（处理前面的子问题）
        Print_MED(Rec, s, t, i - 1, j)
        # 打印删除操作
        print(f"删除'{s[i-1]}'")
    
    # 情况3: 方向为"L"，表示插入操作
    # 从(i,j-1)转移到(i,j)，需要插入t[j-1]
    else:
        # 先递归处理左方（处理前面的子问题）
        Print_MED(Rec, s, t, i, j - 1)
        # 打印插入操作
        print(f"插入'{t[j-1]}'")


# ------------------------------------------------------------------
# 主程序测试
# ------------------------------------------------------------------
if __name__ == "__main__":
    # 测试用例
    s = "ABCBDAB"  # 源字符串
    t = "BDCABA"   # 目标字符串
    
    # 计算最小编辑距离
    D, Rec = Minimum_Edit_Distance(s, t)
    
    # 打印DP表（调试用）
    print("最小编辑距离DP表:")
    for row in D:
        print(row)
    
    print(f"\n编辑距离: {D[len(s)][len(t)]}")
    
    # 获取字符串长度作为回溯起点
    i = len(s)
    j = len(t)
    
    # 打印编辑操作序列
    print(f"\n从'{s}'转换为'{t}'的编辑操作:")
    Print_MED(Rec, s, t, i, j)
    print("完成！")