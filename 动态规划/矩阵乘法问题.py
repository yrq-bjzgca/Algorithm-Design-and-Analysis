import math

def Matrix_Chain_Order(p):
    """
    矩阵链乘法最优计算顺序（求最小标量乘法次数）
    
    参数:
        p: 数组，p[i-1]×p[i] 表示第i个矩阵的维度
           例如: p = [2,3,7,9,5,2,4] 表示6个矩阵：
           M1:2×3, M2:3×7, M3:7×9, M4:9×5, M5:5×2, M6:2×4
    
    返回:
        m: DP表，m[i][j]表示计算矩阵Mi到Mj的最小乘法次数
        s: 分割点表，s[i][j]记录最优分割位置k
    """
    n = len(p) - 1  # 矩阵个数 = p的长度 - 1
    
    # ------------------------------------------------------------------
    # 阶段1: 初始化DP表
    # ------------------------------------------------------------------
    # m[i][j] 表示第i个矩阵到第j个矩阵（1-indexed）的最小乘法次数
    m = [[0] * (n + 1) for _ in range(n + 1)]
    
    # s[i][j] 记录达到最小值时的分割点k，即 Mi..Mj = (Mi..Mk) × (Mk+1..Mj)
    s = [[0] * (n + 1) for _ in range(n + 1)]
    
    # ------------------------------------------------------------------
    # 阶段2: 动态规划（按链长度递增计算）
    # ------------------------------------------------------------------
    # l 表示矩阵链的长度（包含多少个矩阵）
    for l in range(2, n + 1):  # l = 2,3,...,n
        
        # i 表示链的起始矩阵编号（1-indexed）
        for i in range(1, n - l + 2):
            
            # j 表示链的结束矩阵编号
            j = i + l - 1
            
            # 初始化m[i][j]为无穷大
            m[i][j] = math.inf
            
            # 遍历所有可能的分割点k
            for k in range(i, j):
                
                # 计算分割点k的代价
                q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]
                
                # 如果此分割点的代价更小，更新最优解
                if q < m[i][j]:
                    m[i][j] = q
                    s[i][j] = k
    
    # ------------------------------------------------------------------
    # 阶段3: 返回结果
    # ------------------------------------------------------------------
    return m, s


def Print_Optimal_Parens(s, i, j):
    """
    根据分割点表s，打印矩阵链的最优括号化方案
    
    参数:
        s: 分割点表（来自Matrix_Chain_Order函数）
        i: 起始矩阵编号（1-indexed）
        j: 结束矩阵编号（1-indexed）
    """
    if i == j:
        print(f"A{i}", end='')
    else:
        print("(", end='')
        k = s[i][j]
        Print_Optimal_Parens(s, i, k)
        Print_Optimal_Parens(s, k + 1, j)
        print(")", end='')


# ------------------------------------------------------------------
# 主程序测试
# ------------------------------------------------------------------
if __name__ == "__main__":
    p = [2, 3, 7, 9, 5, 2, 4]
    
    m, s = Matrix_Chain_Order(p)
    
    n = len(p) - 1
    print(f"矩阵个数: {n}")
    
    print("\n最小乘法次数表 m:")
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            if j >= i:
                print(f"{m[i][j]:4d}", end='')
            else:
                print("    ", end='')
        print()
    
    print("\n最优括号化方案:")
    Print_Optimal_Parens(s, 1, n)
    print(f"\n\n最小标量乘法次数: {m[1][n]}")