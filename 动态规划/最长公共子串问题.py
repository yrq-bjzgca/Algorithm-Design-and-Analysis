def Longest_common_substring(X, Y):
    """
    求解两个字符串的最长公共子串（Longest Common Substring）
    与子序列不同，子串要求字符在原字符串中连续出现
    
    参数:
        X: 字符串1
        Y: 字符串2
    
    返回:
        lmax: 最长公共子串的长度
        pmax: 最长公共子串在X中的结束位置（0-based索引）
    """
    n = len(X)  # 字符串X的长度
    m = len(Y)  # 字符串Y的长度
    
    # ------------------------------------------------------------------
    # 阶段1: 初始化DP表
    # ------------------------------------------------------------------
    # 创建 (n+1) x (m+1) 的二维数组C
    # C[i][j] 表示以 X[i-1] 和 Y[j-1] 结尾的最长公共子串的长度
    # 额外的一行和一列（i=0或j=0）作为边界，初始化为0，简化边界条件处理
    C = [[0] * (m + 1) for _ in range(n + 1)]
    
    lmax = 0  # 记录全局最大长度
    pmax = 0  # 记录最长公共子串在X中的结束索引
    
    # ------------------------------------------------------------------
    # 阶段2: 填充DP表（动态规划核心）
    # ------------------------------------------------------------------
    # 遍历字符串X的每个字符，i是DP表的行索引（从1开始）
    # i-1 才是对应字符在X中的实际索引
    for i in range(1, n + 1):
        
        # 遍历字符串Y的每个字符，j是DP表的列索引（从1开始）
        # j-1 才是对应字符在Y中的实际索引
        for j in range(1, m + 1):
            
            # 如果当前字符匹配
            # X[i-1] 是字符串X中索引为i-1的字符
            # Y[j-1] 是字符串Y中索引为j-1的字符
            if X[i - 1] == Y[j - 1]:
                # 当前公共子串长度 = 左上角值 + 1
                # 因为字符匹配，所以长度在之前的公共子串基础上+1
                C[i][j] = C[i - 1][j - 1] + 1
                
                # 更新全局最大值
                # 如果当前子串长度大于已知最大长度
                if C[i][j] > lmax:
                    lmax = C[i][j]      # 更新最大长度
                    pmax = i - 1        # 记录实际字符索引（i-1）
            
            # 如果字符不匹配，当前公共子串长度重置为0
            # 因为子串要求连续，一旦断开就要重新开始
            else:
                C[i][j] = 0
    
    # ------------------------------------------------------------------
    # 阶段3: 返回结果
    # ------------------------------------------------------------------
    # lmax: 最长公共子串的长度
    # pmax: 该子串在X中的结束位置（索引）
    return lmax, pmax


def print_LCS(X, lmax, pmax):
    """
    打印最长公共子串
    
    参数:
        X: 原始字符串
        lmax: 子串长度
        pmax: 子串在X中的结束索引
    """
    # 如果长度为0，说明没有公共子串
    if lmax == 0:
        print("没有公共子串")
        return
    
    # ------------------------------------------------------------------
    # 阶段4: 提取并打印子串
    # ------------------------------------------------------------------
    # 通过切片从X中提取子串
    # 起始位置 = pmax - lmax + 1
    # 结束位置 = pmax + 1 （Python切片是左闭右开）
    # 例如: X="ABCADBB", 最长公共子串是"BB"
    # pmax=6, lmax=2, 切片X[5:7]得到"BB"
    
    # 修复点: 循环范围应包含pmax，所以是pmax+1
    for i in range(pmax - lmax + 1, pmax + 1):
        # 打印字符但不换行，end=''使所有字符连续输出
        print(X[i], end='')
    
    # 打印完成后输出一个换行符，美化输出
    print()


# ------------------------------------------------------------------
# 主程序测试
# ------------------------------------------------------------------
if __name__ == "__main__":
    X = "ABCADBB"
    Y = "BCEDBB"
    
    # 求解最长公共子串
    lmax, pmax = Longest_common_substring(X, Y)
    
    # 打印结果
    print(f"字符串X: {X}")
    print(f"字符串Y: {Y}")
    print(f"最长公共子串长度: {lmax}")
    print(f"在X中的位置: [{pmax-lmax+1}:{pmax+1}]")
    print(f"子串内容: ", end='')
    print_LCS(X, lmax, pmax)